\documentclass[10pt,]{article}
\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}

\geometry{
    top=1.0in,
    inner=1.0in,
    outer=1.0in,
    bottom=1.0in,
    headheight=3ex,
    headsep=2ex,
}

\else % if luatex or xelatex
  \usepackage{fontspec}
  \ifxetex
    \usepackage{xltxtra,xunicode}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi

\usepackage{fancyhdr}
\pagestyle{fancyplain}
\pagenumbering{arabic}
\lhead{University of Southampton}
\chead{}
\rhead{\thepage}
\lfoot{}
\cfoot{}
\rfoot{}

\usepackage{color}
\usepackage{fancyvrb}
\DefineShortVerb[commandchars=\\\{\}]{\|}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={UoS ACM Notebook},
            colorlinks=true,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines

\title{UoS ACM Notebook}
\author{}
\date{}

\begin{document}
\maketitle

\section{Data Structures}

\subsection{Binary indexed tree}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{AIB[Nmax],v[Nmax],M,x,y,z;}
\DataTypeTok{int} \NormalTok{N,num;}

\KeywordTok{inline} \DataTypeTok{int} \NormalTok{zeros(}\DataTypeTok{int} \NormalTok{x) \{}
  \KeywordTok{return} \NormalTok{((x ^ (x - }\DecValTok{1}\NormalTok{)) & x );}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void} \NormalTok{Add(}\DataTypeTok{int} \NormalTok{x, }\DataTypeTok{int} \NormalTok{q) \{}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = x; i <= N; i += zeros(i))}
    \NormalTok{AIB[i]+=q;}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{int} \NormalTok{comp(}\DataTypeTok{int} \NormalTok{x) \{}
  \DataTypeTok{int} \NormalTok{i, ret = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(i = x; i > }\DecValTok{0}\NormalTok{; i -= zeros(i))}
    \NormalTok{ret +=AIB[i];}
  \KeywordTok{return} \NormalTok{ret;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Segment tree}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{long} \DataTypeTok{long} \NormalTok{aint[}\DecValTok{4}\NormalTok{*Nmax}\DecValTok{+100}\NormalTok{],v[Nmax],maxim,M,x,z,y,indic;}
\DataTypeTok{long} \DataTypeTok{long} \NormalTok{up[}\DecValTok{4}\NormalTok{*Nmax}\DecValTok{+100}\NormalTok{];}
\DataTypeTok{long} \DataTypeTok{long} \NormalTok{ind[}\DecValTok{4}\NormalTok{*Nmax}\DecValTok{+100}\NormalTok{];}
\DataTypeTok{long} \DataTypeTok{long} \NormalTok{SUM,SUMI;}
\DataTypeTok{long} \DataTypeTok{long} \NormalTok{N;}
\DataTypeTok{long} \DataTypeTok{long} \NormalTok{inf = (}\DataTypeTok{long} \DataTypeTok{long}\NormalTok{)}\DecValTok{101010000}\NormalTok{*}\DecValTok{100}\NormalTok{;}

\KeywordTok{inline} \DataTypeTok{void} \NormalTok{relax(}\DataTypeTok{int} \NormalTok{nod,}\DataTypeTok{int} \NormalTok{st,}\DataTypeTok{int} \NormalTok{dr) \{}
  \DataTypeTok{long} \DataTypeTok{long} \NormalTok{mij=(st+dr)/}\DecValTok{2}\NormalTok{;}
  \DataTypeTok{long} \DataTypeTok{long} \NormalTok{val=up[nod];}
  \KeywordTok{if}\NormalTok{(st!=dr) \{}
    \NormalTok{up[}\DecValTok{2}\NormalTok{*nod]+=val;}
    \NormalTok{up[}\DecValTok{2}\NormalTok{*nod}\DecValTok{+1}\NormalTok{]+=val;}
  \NormalTok{\}}
  \KeywordTok{if}\NormalTok{(st==dr)}
    \NormalTok{ind[nod]=st;}
  \NormalTok{aint[nod]+=up[nod];}
  \NormalTok{up[nod]=}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{update(}\DataTypeTok{int} \NormalTok{nod,}\DataTypeTok{int} \NormalTok{ist,}\DataTypeTok{int} \NormalTok{idr,}\DataTypeTok{int} \NormalTok{st,}\DataTypeTok{int} \NormalTok{dr,}\DataTypeTok{long} \DataTypeTok{long} \NormalTok{val) \{}
  \KeywordTok{if}\NormalTok{(ist<=st&&idr>=dr) \{}
    \NormalTok{aint[nod]+=val;}
    \KeywordTok{if}\NormalTok{(st!=dr) \{}
      \NormalTok{up[}\DecValTok{2}\NormalTok{*nod]+=val;}
      \NormalTok{up[}\DecValTok{2}\NormalTok{*nod}\DecValTok{+1}\NormalTok{]+=val;}
    \NormalTok{\}}
    \KeywordTok{else} \NormalTok{ind[nod]=ist;}
  \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \KeywordTok{if}\NormalTok{(aint[nod]>}\DecValTok{0}\NormalTok{)}
      \NormalTok{relax(nod,st,dr);}
    \DataTypeTok{long} \DataTypeTok{long} \NormalTok{mij=(st+dr)/}\DecValTok{2}\NormalTok{;}

    \KeywordTok{if}\NormalTok{(ist<=mij)}
      \NormalTok{update(}\DecValTok{2}\NormalTok{*nod,ist,idr,st,mij,val);}
    \KeywordTok{if}\NormalTok{(idr>mij)}
      \NormalTok{update(}\DecValTok{2}\NormalTok{*nod}\DecValTok{+1}\NormalTok{,ist,idr,mij}\DecValTok{+1}\NormalTok{,dr,val);}
    \KeywordTok{if}\NormalTok{(up[nod*}\DecValTok{2}\NormalTok{])}
      \NormalTok{relax(nod*}\DecValTok{2}\NormalTok{,st,mij);}
    \KeywordTok{if}\NormalTok{(up[nod*}\DecValTok{2+1}\NormalTok{])}
      \NormalTok{relax(nod*}\DecValTok{2+1}\NormalTok{,mij}\DecValTok{+1}\NormalTok{,dr);}
    \KeywordTok{if}\NormalTok{(aint[nod*}\DecValTok{2}\NormalTok{]>aint[nod*}\DecValTok{2+1}\NormalTok{]) \{}
      \NormalTok{aint[nod]=aint[}\DecValTok{2}\NormalTok{*nod}\DecValTok{+1}\NormalTok{];}
      \NormalTok{ind[nod]=ind[}\DecValTok{2}\NormalTok{*nod}\DecValTok{+1}\NormalTok{];}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
      \NormalTok{aint[nod]=aint[}\DecValTok{2}\NormalTok{*nod];}
      \NormalTok{ind[nod]=ind[}\DecValTok{2}\NormalTok{*nod];}
    \NormalTok{\}}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Treap}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{T \{}
  \DataTypeTok{int} \NormalTok{key, priority,nr;}
  \NormalTok{T *left, *right;}
  \NormalTok{T() \{\}}
  \NormalTok{T(}\DataTypeTok{int} \NormalTok{key, }\DataTypeTok{int} \NormalTok{priority, T* left, T* right) \{}
    \KeywordTok{this}\NormalTok{->key = key;}
    \KeywordTok{this}\NormalTok{->priority = priority;}
    \KeywordTok{this}\NormalTok{->left = left, }\KeywordTok{this}\NormalTok{->right = right;}
    \KeywordTok{this}\NormalTok{->nr = }\DecValTok{0}\NormalTok{;}
  \NormalTok{\}}
\NormalTok{\} *R, *nil; }\CommentTok{// nil indica un nod 'gol'}

\DataTypeTok{void} \NormalTok{init(T* &R) \{}
  \NormalTok{srand(}\DataTypeTok{unsigned}\NormalTok{(time(}\DecValTok{0}\NormalTok{)));}
  \NormalTok{R = nil = }\KeywordTok{new} \NormalTok{T(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, NULL, NULL);}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{parc(T* n)\{}
  \KeywordTok{if}\NormalTok{(n== nil)}
    \KeywordTok{return}\NormalTok{;}
  \NormalTok{parc(n->left);}
  \NormalTok{parc(n->right);}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void} \NormalTok{update(T* &n)\{}
  \KeywordTok{if}\NormalTok{(n==nil)}
    \KeywordTok{return}\NormalTok{;}
  \NormalTok{n->nr = n->left->nr + n->right->nr + }\DecValTok{1}\NormalTok{;}

\NormalTok{\}}
\DataTypeTok{int} \NormalTok{search(T* n, }\DataTypeTok{int} \NormalTok{key) \{}
  \KeywordTok{if} \NormalTok{(n == nil) }\KeywordTok{return} \DecValTok{0}\NormalTok{;}
  \KeywordTok{if} \NormalTok{(key == n->key) }\KeywordTok{return} \DecValTok{1}\NormalTok{;}
  \KeywordTok{if} \NormalTok{(key < n->key)}
    \KeywordTok{return} \NormalTok{search(n->left, key);}
  \KeywordTok{else}
    \KeywordTok{return} \NormalTok{search(n->right, key);}
  \NormalTok{update(n->right);}
  \NormalTok{update(n->left);}
  \NormalTok{update(n);}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{rotleft(T* &n) \{}
  \NormalTok{T *t = n->left;}
  \NormalTok{n->left = t->right, t->right = n;}
  \NormalTok{n = t;}
  \NormalTok{update(t->right);}
  \NormalTok{update(t->left);}
  \NormalTok{update(t);}
  \NormalTok{update(n->right);}
  \NormalTok{update(n);}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{rotright(T* &n) \{}
  \NormalTok{T *t = n->right;}
  \NormalTok{n->right = t->left, t->left = n;}
  \NormalTok{n = t;}
  \NormalTok{update(t->right);}
  \NormalTok{update(t->left);}
  \NormalTok{update(t);}
  \NormalTok{update(n->left);}
  \NormalTok{update(n);}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{nth(T* &n,}\DataTypeTok{int} \NormalTok{nr)\{}
  \KeywordTok{if}\NormalTok{(n==nil)}
    \KeywordTok{return} \NormalTok{-}\DecValTok{1}\NormalTok{;}
  \KeywordTok{if}\NormalTok{(nr==}\DecValTok{0}\NormalTok{)}
    \KeywordTok{return} \NormalTok{n->key;}
  \DataTypeTok{int} \NormalTok{leftval = n->left->nr;}
  \KeywordTok{if}\NormalTok{(nr-leftval == }\DecValTok{1}\NormalTok{)}
    \KeywordTok{return} \NormalTok{n->key;}
  \KeywordTok{if}\NormalTok{(leftval >= nr)}
    \KeywordTok{return} \NormalTok{nth(n->left,nr);}
  \KeywordTok{return} \NormalTok{nth(n->right,nr-leftval}\DecValTok{-1}\NormalTok{);}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{balance(T* &n) \{}
  \KeywordTok{if} \NormalTok{(n->left->priority > n->priority)}
    \NormalTok{rotleft(n);}
  \KeywordTok{else} \KeywordTok{if} \NormalTok{(n->right->priority > n->priority)}
    \NormalTok{rotright(n);}
  \NormalTok{update(n->right);}
  \NormalTok{update(n->left);}
  \NormalTok{update(n);}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{insert(T* &n, }\DataTypeTok{int} \NormalTok{key, }\DataTypeTok{int} \NormalTok{priority) \{}
  \KeywordTok{if} \NormalTok{(n == nil) \{}
    \NormalTok{n = }\KeywordTok{new} \NormalTok{T(key, priority, nil, nil);}
    \NormalTok{n->nr=}\DecValTok{1}\NormalTok{;}
    \KeywordTok{return}\NormalTok{;}
  \NormalTok{\}}
  \NormalTok{(n->nr)++;}
  \KeywordTok{if} \NormalTok{(key <= n->key)}
    \NormalTok{insert(n->left, key, priority);}
  \KeywordTok{else} \KeywordTok{if} \NormalTok{(key > n->key)}
    \NormalTok{insert(n->right, key, priority);}
  \NormalTok{balance(n);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Maximum Flows}

\subsection{Max flow}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{flux[}\DecValTok{1010}\NormalTok{][}\DecValTok{1010}\NormalTok{];}
\DataTypeTok{int} \NormalTok{c[}\DecValTok{1010}\NormalTok{][}\DecValTok{1010}\NormalTok{];}
\DataTypeTok{int} \NormalTok{tata[}\DecValTok{1010}\NormalTok{];}
\DataTypeTok{int} \NormalTok{viz[}\DecValTok{1010}\NormalTok{],flow;}
\DataTypeTok{int} \NormalTok{coad[}\DecValTok{1015}\NormalTok{];}
\DataTypeTok{int} \NormalTok{Q,x,y,z,N,act,M,flow_min;}

\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> g[}\DecValTok{1010}\NormalTok{];}

\DataTypeTok{int} \NormalTok{BF() \{}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{1}\NormalTok{;i<=N;++i) \{}
    \NormalTok{viz[i]=}\DecValTok{0}\NormalTok{;}
  \NormalTok{\}}
  \NormalTok{coad[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;}
  \DataTypeTok{int} \NormalTok{st=}\DecValTok{0}\NormalTok{,dr=}\DecValTok{1}\NormalTok{;}
  \NormalTok{viz[}\DecValTok{1}\NormalTok{]=}\DecValTok{1}\NormalTok{;}
  \KeywordTok{while}\NormalTok{(st<dr) \{}
    \NormalTok{act=coad[st];}
    \KeywordTok{if}\NormalTok{(act!=N)}
      \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<g[act].size();++i) \{}
        \NormalTok{Q = g[act][i];}
        \KeywordTok{if}\NormalTok{(c[act][Q] == flux[act][Q] \textbar{}\textbar{} viz[Q])}
          \KeywordTok{continue}\NormalTok{;}
        \NormalTok{viz[Q]=}\DecValTok{1}\NormalTok{;}
        \NormalTok{coad[dr++]=Q;}
        \NormalTok{tata[Q]=act;}
      \NormalTok{\}}
    \NormalTok{++st;}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{viz[N];}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{main() \{}
  \KeywordTok{for}\NormalTok{(flow=}\DecValTok{0}\NormalTok{; BF();) \{}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<g[N].size();++i) \{}
      \NormalTok{act=g[N][i];}
      \KeywordTok{if}\NormalTok{(flux[act][N]==c[act][N] \textbar{}\textbar{}!viz[act])}
        \KeywordTok{continue}\NormalTok{;}
      \NormalTok{tata[N]=act;}

      \NormalTok{flow_min=}\DecValTok{10101000}\NormalTok{;}
      \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{nod=N;nod!=}\DecValTok{1}\NormalTok{;nod=tata[nod])}
        \NormalTok{flow_min=min(flow_min,c[tata[nod]][nod]-flux[tata[nod]][nod]);}
      \KeywordTok{if}\NormalTok{(flow_min==}\DecValTok{0}\NormalTok{)}
        \KeywordTok{continue}\NormalTok{;}
      \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{nod=N;nod!=}\DecValTok{1}\NormalTok{;nod=tata[nod]) \{}
        \NormalTok{flux[tata[nod]][nod]+=flow_min;}
        \NormalTok{flux[nod][tata[nod]]-=flow_min;}
      \NormalTok{\}}
      \NormalTok{flow+=flow_min;}
    \NormalTok{\}}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Min cost max flow}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{N, M, S, D;}
\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> G[MAXN];}

\DataTypeTok{int} \NormalTok{cap[MAXN][MAXN];}
\DataTypeTok{int} \NormalTok{cost[MAXN][MAXN];}
\DataTypeTok{int} \NormalTok{flow[MAXN][MAXN];}

\DataTypeTok{int} \NormalTok{d[MAXN];}
\DataTypeTok{int} \NormalTok{prev[MAXN];}
\DataTypeTok{bool} \NormalTok{found;}

\DataTypeTok{int} \NormalTok{bellman_ford() \{}
  \NormalTok{vector<}\DataTypeTok{bool}\NormalTok{> inqueue(N + }\DecValTok{1}\NormalTok{, }\KeywordTok{false}\NormalTok{);}
  \NormalTok{queue<}\DataTypeTok{int}\NormalTok{> q;}
  \NormalTok{q.push(S);}
  \NormalTok{inqueue[S] = }\KeywordTok{true}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{1}\NormalTok{; i <= N; ++i) \{}
    \NormalTok{prev[i] = -}\DecValTok{1}\NormalTok{;}
    \NormalTok{d[i] = INF;}
  \NormalTok{\}}
  \NormalTok{d[S] = }\DecValTok{0}\NormalTok{;}

  \KeywordTok{while} \NormalTok{(!q.empty()) \{}
    \DataTypeTok{int} \NormalTok{node = q.front();}
    \NormalTok{q.pop();}
    \NormalTok{inqueue[node] = }\KeywordTok{false}\NormalTok{;}
    \NormalTok{vector<}\DataTypeTok{int}\NormalTok{>::iterator it;}
    \KeywordTok{for} \NormalTok{(it = G[node].begin(); it != G[node].end(); ++it) \{}
      \KeywordTok{if} \NormalTok{(cap[node][*it] - flow[node][*it] <= }\DecValTok{0}\NormalTok{)}
        \KeywordTok{continue}\NormalTok{;}
      \KeywordTok{if} \NormalTok{(cost[node][*it] + d[node] < d[*it]) \{}
        \NormalTok{prev[*it] = node;}
        \NormalTok{d[*it] = cost[node][*it] + d[node];}
        \KeywordTok{if} \NormalTok{(!inqueue[*it]) \{}
          \NormalTok{q.push(*it);}
          \NormalTok{inqueue[*it] = }\KeywordTok{true}\NormalTok{;}
        \NormalTok{\}}
      \NormalTok{\}}
    \NormalTok{\}}
  \NormalTok{\}}

  \KeywordTok{if} \NormalTok{(d[D] < INF / }\DecValTok{2}\NormalTok{) \{}
    \NormalTok{found = }\KeywordTok{true}\NormalTok{;}
    \DataTypeTok{int} \NormalTok{fmin = INF;}
    \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{node = D; node != S; node = prev[node])}
      \NormalTok{fmin = min(fmin, cap[prev[node]][node] - flow[prev[node]][node]);}
    \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{node = D; node != S; node = prev[node]) \{}
      \NormalTok{flow[prev[node]][node] += fmin;}
      \NormalTok{flow[node][prev[node]] -= fmin;}
    \NormalTok{\}}
    \KeywordTok{return} \NormalTok{d[D] * fmin;}
  \NormalTok{\}}
  \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{long} \DataTypeTok{long} \NormalTok{mfmc() \{}
  \DataTypeTok{long} \DataTypeTok{long} \NormalTok{result = }\DecValTok{0}\NormalTok{;}
  \NormalTok{found = }\KeywordTok{true}\NormalTok{;}
  \KeywordTok{while} \NormalTok{(found) \{}
    \NormalTok{found = }\KeywordTok{false}\NormalTok{;}
    \NormalTok{result += bellman_ford();}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{result;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Graphs}

\subsection{Bellman-Ford}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{bellmanford() \{}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{1}\NormalTok{; i <= n; ++i)}
      \NormalTok{dist[i] = INF;}
  \NormalTok{dist[}\DecValTok{1}\NormalTok{] = }\DecValTok{0}\NormalTok{;}

  \NormalTok{queue<}\DataTypeTok{int}\NormalTok{> q;}
  \NormalTok{q.push(}\DecValTok{1}\NormalTok{);}
  \NormalTok{inqueue[}\DecValTok{1}\NormalTok{] = }\KeywordTok{true}\NormalTok{;}
  \NormalTok{cnt[}\DecValTok{1}\NormalTok{] = }\DecValTok{1}\NormalTok{;}
  \KeywordTok{while} \NormalTok{(!q.empty()) \{}
    \DataTypeTok{int} \NormalTok{node = q.front();}
    \NormalTok{q.pop();}
    \NormalTok{inqueue[node] = }\KeywordTok{false}\NormalTok{;}
    \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < G[node].size(); ++i) \{}
      \DataTypeTok{int} \NormalTok{next = G[node][i];}
      \KeywordTok{if} \NormalTok{(dist[node] + C[node][i] < dist[next]) \{}
        \NormalTok{dist[next] = dist[node] + C[node][i];}
        \KeywordTok{if} \NormalTok{(!inqueue[next]) \{}
          \KeywordTok{if} \NormalTok{(cnt[next] > n)}
            \KeywordTok{return} \NormalTok{-}\DecValTok{1}\NormalTok{;}
          \NormalTok{q.push(next);}
          \NormalTok{inqueue[next] = }\KeywordTok{true}\NormalTok{;}
          \NormalTok{cnt[next]++;}
        \NormalTok{\}}
      \NormalTok{\}}
    \NormalTok{\}}
  \NormalTok{\}}
  \KeywordTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Euler cycle}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list<}\DataTypeTok{int}\NormalTok{> G[MAXN];}
\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> sol;}
\DataTypeTok{int} \NormalTok{deg[MAXN];}
\DataTypeTok{bool} \NormalTok{vis[MAXN];}
\DataTypeTok{void} \NormalTok{dfs(}\DataTypeTok{int} \NormalTok{node) \{}
  \NormalTok{vis[node] = }\KeywordTok{true}\NormalTok{;}
  \NormalTok{list<}\DataTypeTok{int}\NormalTok{>::iterator it;}
  \KeywordTok{for} \NormalTok{(it = G[node].begin(); it != G[node].end(); ++it) \{}
    \KeywordTok{if} \NormalTok{(vis[*it])}
      \KeywordTok{continue}\NormalTok{;}
    \NormalTok{dfs(*it);}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{rem_edge(}\DataTypeTok{int} \NormalTok{v, }\DataTypeTok{int} \NormalTok{w) \{}
  \NormalTok{G[v].pop_front();}
  \NormalTok{list<}\DataTypeTok{int}\NormalTok{>::iterator it;}
  \KeywordTok{for} \NormalTok{(it = G[w].begin(); it != G[w].end(); ++it)}
    \KeywordTok{if} \NormalTok{(*it == v) \{}
      \NormalTok{G[w].erase(it);}
      \KeywordTok{break}\NormalTok{;}
    \NormalTok{\}}
\NormalTok{\}}

\NormalTok{stack<}\DataTypeTok{int}\NormalTok{> st;}
\DataTypeTok{void} \NormalTok{euler(}\DataTypeTok{int} \NormalTok{v) \{}
  \KeywordTok{while} \NormalTok{(!G[v].empty()) \{}
    \DataTypeTok{int} \NormalTok{w = *G[v].begin();}
    \NormalTok{rem_edge(v, w);}
    \NormalTok{st.push(v);}
    \NormalTok{v = w;}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{st.push(}\DecValTok{1}\NormalTok{);}
  \KeywordTok{while} \NormalTok{(!st.empty()) \{}
    \DataTypeTok{int} \NormalTok{v = st.top();}
    \NormalTok{st.pop();}
    \NormalTok{euler(v);}
    \NormalTok{sol.push_back(v);}
  \NormalTok{\}}
  \NormalTok{reverse(sol.begin(), sol.end());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Maximum matching}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{N,M,K;}
\DataTypeTok{int} \NormalTok{v[}\DecValTok{25000}\NormalTok{],x,p=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{char} \NormalTok{car;}
\NormalTok{vector <}\DataTypeTok{int}\NormalTok{> g[}\DecValTok{25000}\NormalTok{];}
\DataTypeTok{int} \NormalTok{l[}\DecValTok{25000}\NormalTok{],r[}\DecValTok{25000}\NormalTok{],u[}\DecValTok{25000}\NormalTok{],was[}\DecValTok{25000}\NormalTok{],S;}
\DataTypeTok{int} \NormalTok{cupj(}\DataTypeTok{int} \NormalTok{q) \{}
  \KeywordTok{if}\NormalTok{(was[q])}
    \KeywordTok{return} \DecValTok{0}\NormalTok{;}
  \NormalTok{was[q]=}\DecValTok{1}\NormalTok{;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<g[q].size();++i) \{}
    \KeywordTok{if}\NormalTok{(!r[g[q][i]]) \{}
      \NormalTok{l[q]=g[q][i];}
      \NormalTok{r[g[q][i]]=q;}
      \KeywordTok{return} \DecValTok{1}\NormalTok{;}
    \NormalTok{\}}
  \NormalTok{\}}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<g[q].size();++i) \{}
    \KeywordTok{if}\NormalTok{(cupj(r[g[q][i]])) \{}
      \NormalTok{l[q]=g[q][i];}
      \NormalTok{r[g[q][i]]=q;}
      \KeywordTok{return} \DecValTok{1}\NormalTok{;}
    \NormalTok{\}}
  \NormalTok{\}}
  \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Hamiltonian path}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{int} \NormalTok{inf = }\DecValTok{1000000000}\NormalTok{;}
\DataTypeTok{int} \NormalTok{N,M,x,y,z,Sol,b[}\DecValTok{262150}\NormalTok{][}\DecValTok{22}\NormalTok{],c[}\DecValTok{22}\NormalTok{][}\DecValTok{22}\NormalTok{];}
\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> a[}\DecValTok{22}\NormalTok{];}

\DataTypeTok{int} \NormalTok{best(}\DataTypeTok{int} \NormalTok{conf, }\DataTypeTok{int} \NormalTok{last) \{}
  \KeywordTok{if}\NormalTok{(b[conf][last]>=}\DecValTok{0}\NormalTok{)}
    \KeywordTok{return} \NormalTok{b[conf][last];}
  \NormalTok{b[conf][last]=inf;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<a[last].size();++i)}
    \KeywordTok{if}\NormalTok{(conf & (}\DecValTok{1}\NormalTok{<<a[last][i])) \{}
      \KeywordTok{if}\NormalTok{(a[last][i]==}\DecValTok{0} \NormalTok{&& conf!=(}\DecValTok{1}\NormalTok{<<last)+}\DecValTok{1}\NormalTok{)}
        \KeywordTok{continue}\NormalTok{;}
      \KeywordTok{if}\NormalTok{(b[conf][last] > best(conf^(}\DecValTok{1}\NormalTok{<<last),a[last][i])+c[a[last][i]][last])}
        \NormalTok{b[conf][last] = best(conf^(}\DecValTok{1}\NormalTok{<<last),a[last][i])+c[a[last][i]][last];}
    \NormalTok{\}}
  \KeywordTok{return} \NormalTok{b[conf][last];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Heavy path decomposition}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{N, M, nL;}
\DataTypeTok{int} \NormalTok{v[MAXN], fol[MAXN], niv[MAXN], w[MAXN], l[MAXN];}
\DataTypeTok{int} \NormalTok{aint[}\DecValTok{4}\NormalTok{*MAXN];}
\DataTypeTok{int} \NormalTok{lTata[MAXN], lNiv[MAXN], lDim[MAXN], lPoz[MAXN];}
\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> G[MAXN], P[MAXN];}
\NormalTok{pair<}\DataTypeTok{int}\NormalTok{, pair<}\DataTypeTok{int}\NormalTok{, }\DataTypeTok{int}\NormalTok{> > op[MAXN];}

\DataTypeTok{void} \NormalTok{df(}\DataTypeTok{int} \NormalTok{nod) \{}
  \NormalTok{fol[nod] = }\DecValTok{1}\NormalTok{;}
  \NormalTok{w[nod] = }\DecValTok{1}\NormalTok{;}
  \DataTypeTok{int} \NormalTok{hN = -}\DecValTok{1}\NormalTok{, frunza = }\DecValTok{1}\NormalTok{;}

  \KeywordTok{for}\NormalTok{(vector<}\DataTypeTok{int}\NormalTok{> :: iterator it = G[nod].begin(); it != G[nod].end(); ++it) \{}
    \KeywordTok{if}\NormalTok{(fol[*it])}
      \KeywordTok{continue}\NormalTok{;}
    \NormalTok{frunza = }\DecValTok{0}\NormalTok{;}
    \NormalTok{niv[*it] = niv[nod] + }\DecValTok{1}\NormalTok{;}
    \NormalTok{df(*it);}
    \NormalTok{w[nod] += w[*it];}
    \KeywordTok{if}\NormalTok{(hN == -}\DecValTok{1}\NormalTok{)}
      \NormalTok{hN = *it;}
    \KeywordTok{else} \KeywordTok{if}\NormalTok{(w[hN] < w[*it])}
      \NormalTok{hN = *it;}
  \NormalTok{\}}
  \KeywordTok{if}\NormalTok{(frunza) \{}
    \NormalTok{l[nod] = ++nL;}
    \NormalTok{lDim[nL]=}\DecValTok{1}\NormalTok{;}
    \NormalTok{P[nL].push_back(nod);}
    \KeywordTok{return}\NormalTok{;}
  \NormalTok{\}}
  \NormalTok{l[nod] = l[hN];}
  \NormalTok{++lDim[l[nod]];}
  \NormalTok{P[l[nod]].push_back(nod);}

  \KeywordTok{for}\NormalTok{(vector<}\DataTypeTok{int}\NormalTok{> :: iterator it = G[nod].begin(); it != G[nod].end(); ++it) \{}
    \KeywordTok{if}\NormalTok{((*it) == hN \textbar{}\textbar{} niv[*it] < niv[nod])}
      \KeywordTok{continue}\NormalTok{;}

    \NormalTok{lTata[l[*it]] = nod;}
    \NormalTok{lNiv[l[*it]] = niv[nod];}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{build(}\DataTypeTok{int} \NormalTok{nod, }\DataTypeTok{int} \NormalTok{left, }\DataTypeTok{int} \NormalTok{right, }\DataTypeTok{int} \NormalTok{decalaj, }\DataTypeTok{int} \NormalTok{lant) \{}
  \KeywordTok{if}\NormalTok{(left == right) \{}
    \NormalTok{aint[nod + decalaj] = v[ P[lant][left - }\DecValTok{1}\NormalTok{] ];}
    \KeywordTok{return}\NormalTok{;}
  \NormalTok{\}}
  \DataTypeTok{int} \NormalTok{med = (left + right) / }\DecValTok{2}\NormalTok{;}
  \NormalTok{build(nod * }\DecValTok{2}\NormalTok{, left, med, decalaj, lant);}
  \NormalTok{build(nod * }\DecValTok{2} \NormalTok{+ }\DecValTok{1}\NormalTok{, med}\DecValTok{+1}\NormalTok{, right, decalaj, lant);}
  \NormalTok{aint[nod + decalaj] = max(aint[nod * }\DecValTok{2} \NormalTok{+ decalaj], aint[nod * }\DecValTok{2} \NormalTok{+ }\DecValTok{1} \NormalTok{+ decalaj]);}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{make_paths() \{}
  \NormalTok{niv[}\DecValTok{1}\NormalTok{] = }\DecValTok{1}\NormalTok{;}
  \NormalTok{df(}\DecValTok{1}\NormalTok{);}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{1}\NormalTok{; i <= nL; ++i) \{}
    \NormalTok{reverse(P[i].begin(), P[i].end());}
    \KeywordTok{if}\NormalTok{(i > }\DecValTok{1}\NormalTok{)}
      \NormalTok{lPoz[i] = lPoz[i}\DecValTok{-1}\NormalTok{] + lDim[i}\DecValTok{-1}\NormalTok{] * }\DecValTok{4}\NormalTok{;}
    \NormalTok{build(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, lDim[i], lPoz[i], i);}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{update(}\DataTypeTok{int} \NormalTok{nod, }\DataTypeTok{int} \NormalTok{left, }\DataTypeTok{int} \NormalTok{right, }\DataTypeTok{int} \NormalTok{poz, }\DataTypeTok{int} \NormalTok{val, }\DataTypeTok{int} \NormalTok{decalaj) \{}
  \KeywordTok{if}\NormalTok{(left == right) \{}
    \NormalTok{aint[nod + decalaj] = val;}
    \KeywordTok{return}\NormalTok{;}
  \NormalTok{\}}
  \DataTypeTok{int} \NormalTok{med = (left + right) / }\DecValTok{2}\NormalTok{;}
  \KeywordTok{if}\NormalTok{(poz<=med)}
    \NormalTok{update(nod * }\DecValTok{2}\NormalTok{, left, med, poz, val, decalaj);}
  \KeywordTok{else}
    \NormalTok{update(nod * }\DecValTok{2} \NormalTok{+ }\DecValTok{1}\NormalTok{, med}\DecValTok{+1}\NormalTok{, right, poz, val, decalaj);}
  \NormalTok{aint[nod + decalaj] = max(aint[nod * }\DecValTok{2} \NormalTok{+ decalaj], aint[nod * }\DecValTok{2} \NormalTok{+ }\DecValTok{1} \NormalTok{+ decalaj]);}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{query(}\DataTypeTok{int} \NormalTok{nod, }\DataTypeTok{int} \NormalTok{left, }\DataTypeTok{int} \NormalTok{right, }\DataTypeTok{int} \NormalTok{qleft, }\DataTypeTok{int} \NormalTok{qright, }\DataTypeTok{int} \NormalTok{decalaj) \{}
  \KeywordTok{if}\NormalTok{(qleft <= left && right <= qright)}
    \KeywordTok{return} \NormalTok{aint[nod + decalaj];}
  \DataTypeTok{int} \NormalTok{med = (left + right) / }\DecValTok{2}\NormalTok{, rez = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{if}\NormalTok{(qleft <= med)}
    \NormalTok{rez = max(rez, query(nod * }\DecValTok{2}\NormalTok{, left, med, qleft, qright, decalaj) );}
  \KeywordTok{if}\NormalTok{(med < qright)}
    \NormalTok{rez = max(rez, query(nod * }\DecValTok{2} \NormalTok{+ }\DecValTok{1}\NormalTok{, med + }\DecValTok{1}\NormalTok{, right, qleft, qright, decalaj) );}
  \KeywordTok{return} \NormalTok{rez;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{solve() \{}
  \DataTypeTok{int} \NormalTok{t, x, y, sol = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{1}\NormalTok{; i <= M; ++i) \{}
    \NormalTok{t = op[i].first; x = op[i].second.first, y = op[i].second.second;}
    \KeywordTok{if}\NormalTok{(t==}\DecValTok{0}\NormalTok{) \{}
      \NormalTok{update(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, lDim[l[x]], niv[x] - lNiv[l[x]], y, lPoz[l[x]]);}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
      \NormalTok{sol = }\DecValTok{0}\NormalTok{;}
      \KeywordTok{while}\NormalTok{(}\DecValTok{1}\NormalTok{) \{}
        \KeywordTok{if}\NormalTok{(l[x] == l[y]) \{}
          \KeywordTok{if}\NormalTok{(niv[x] > niv[y])}
            \NormalTok{swap(x, y);}
          \NormalTok{sol = max(sol, query(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, lDim[l[x]], niv[x] - lNiv[l[x]], niv[y] - lNiv[l[x]], lPoz[l[x]]));}
          \KeywordTok{break}\NormalTok{;}
        \NormalTok{\}}
        \KeywordTok{if}\NormalTok{(lNiv[l[x]] < lNiv[l[y]])}
          \NormalTok{swap(x, y);}
        \NormalTok{sol = max(sol, query(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, lDim[l[x]], }\DecValTok{1}\NormalTok{, niv[x] - lNiv[l[x]], lPoz[l[x]]));}
        \NormalTok{x = lTata[l[x]];}
      \NormalTok{\}}
    \NormalTok{\}}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Lowest common ancestor}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{K, N, M, x, y, L[}\DecValTok{200010}\NormalTok{], H[}\DecValTok{200010}\NormalTok{], Lg[}\DecValTok{200010}\NormalTok{], First[}\DecValTok{100010}\NormalTok{], Rmq[}\DecValTok{20}\NormalTok{][}\DecValTok{400010}\NormalTok{];}
\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> G[}\DecValTok{100010}\NormalTok{];}

\DataTypeTok{void} \NormalTok{dfs(}\DataTypeTok{int} \NormalTok{nod, }\DataTypeTok{int} \NormalTok{lev) \{}
  \NormalTok{H[++K] = nod;}
  \NormalTok{L[K] = lev;}
  \NormalTok{First[nod] = K;}
  \DataTypeTok{int} \NormalTok{z = G[nod].size();}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<z;++i) \{}
    \NormalTok{dfs(G[nod][i],lev}\DecValTok{+1}\NormalTok{);}
    \NormalTok{H[++K] = nod;}
    \NormalTok{L[K] = lev;}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{rmq() \{}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{2}\NormalTok{;i<=K;++i)}
    \NormalTok{Lg[i] = Lg[i/}\DecValTok{2}\NormalTok{]+}\DecValTok{1}\NormalTok{;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{1}\NormalTok{;i<=K;++i)}
    \NormalTok{Rmq[}\DecValTok{0}\NormalTok{][i]=i;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{1}\NormalTok{;(}\DecValTok{1}\NormalTok{<<i) < K; ++i)}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{j=}\DecValTok{1}\NormalTok{;j<=K-(}\DecValTok{1}\NormalTok{<<i);++j) \{}
      \DataTypeTok{int} \NormalTok{l = }\DecValTok{1}\NormalTok{<< (i}\DecValTok{-1}\NormalTok{);}
      \NormalTok{Rmq[i][j] = Rmq[i}\DecValTok{-1}\NormalTok{][j];}
      \KeywordTok{if}\NormalTok{(L[Rmq[i}\DecValTok{-1}\NormalTok{][j + l]] < L[Rmq[i][j]])}
        \NormalTok{Rmq[i][j] = Rmq[i}\DecValTok{-1}\NormalTok{][j + l];}
    \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{lca(}\DataTypeTok{int} \NormalTok{x, }\DataTypeTok{int} \NormalTok{y) \{}
  \DataTypeTok{int} \NormalTok{a = First[x], b = First[y];}
  \KeywordTok{if}\NormalTok{(a>b) \{}
    \DataTypeTok{int} \NormalTok{c=a;}
    \NormalTok{a=b;}
    \NormalTok{b=c;}
  \NormalTok{\}}
  \DataTypeTok{int} \NormalTok{diff = b - a + }\DecValTok{1}\NormalTok{;}
  \DataTypeTok{int} \NormalTok{l = Lg[diff];}
  \DataTypeTok{int} \NormalTok{sol = Rmq[l][a];}
  \DataTypeTok{int} \NormalTok{sh = diff - (}\DecValTok{1} \NormalTok{<< l);}
  \KeywordTok{if}\NormalTok{(L[sol] > L[Rmq[l][a + sh]])}
    \NormalTok{sol = Rmq[l][a + sh];}
  \KeywordTok{return} \NormalTok{H[sol];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Mathematics}

\subsection{Number theoretic algorithms}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \NormalTok{vector<}\DataTypeTok{int}\NormalTok{> VI;}
\KeywordTok{typedef} \NormalTok{pair<}\DataTypeTok{int}\NormalTok{,}\DataTypeTok{int}\NormalTok{> PII;}

\DataTypeTok{int} \NormalTok{mod(}\DataTypeTok{int} \NormalTok{a, }\DataTypeTok{int} \NormalTok{b) \{}
  \KeywordTok{return} \NormalTok{((a%b)+b)%b;}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{gcd(}\DataTypeTok{int} \NormalTok{a, }\DataTypeTok{int} \NormalTok{b) \{}
  \DataTypeTok{int} \NormalTok{tmp;}
  \KeywordTok{while}\NormalTok{(b)\{a%=b; tmp=a; a=b; b=tmp;\}}
  \KeywordTok{return} \NormalTok{a;}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{lcm(}\DataTypeTok{int} \NormalTok{a, }\DataTypeTok{int} \NormalTok{b) \{}
  \KeywordTok{return} \NormalTok{a/gcd(a,b)*b;}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{extended_euclid(}\DataTypeTok{int} \NormalTok{a, }\DataTypeTok{int} \NormalTok{b, }\DataTypeTok{int} \NormalTok{&x, }\DataTypeTok{int} \NormalTok{&y) \{}
  \DataTypeTok{int} \NormalTok{xx = y = }\DecValTok{0}\NormalTok{;}
  \DataTypeTok{int} \NormalTok{yy = x = }\DecValTok{1}\NormalTok{;}
  \KeywordTok{while} \NormalTok{(b) \{}
    \DataTypeTok{int} \NormalTok{q = a/b;}
    \DataTypeTok{int} \NormalTok{t = b; b = a%b; a = t;}
    \NormalTok{t = xx; xx = x-q*xx; x = t;}
    \NormalTok{t = yy; yy = y-q*yy; y = t;}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{a;}
\NormalTok{\}}
\NormalTok{VI modular_linear_equation_solver(}\DataTypeTok{int} \NormalTok{a, }\DataTypeTok{int} \NormalTok{b, }\DataTypeTok{int} \NormalTok{n) \{}
  \DataTypeTok{int} \NormalTok{x, y;}
  \NormalTok{VI solutions;}
  \DataTypeTok{int} \NormalTok{d = extended_euclid(a, n, x, y);}
  \KeywordTok{if} \NormalTok{(!(b%d)) \{}
    \NormalTok{x = mod (x*(b/d), n);}
    \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < d; i++)}
      \NormalTok{solutions.push_back(mod(x + i*(n/d), n));}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{solutions;}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{mod_inverse(}\DataTypeTok{int} \NormalTok{a, }\DataTypeTok{int} \NormalTok{n) \{}
  \DataTypeTok{int} \NormalTok{x, y;}
  \DataTypeTok{int} \NormalTok{d = extended_euclid(a, n, x, y);}
  \KeywordTok{if} \NormalTok{(d > }\DecValTok{1}\NormalTok{) }\KeywordTok{return} \NormalTok{-}\DecValTok{1}\NormalTok{;}
  \KeywordTok{return} \NormalTok{mod(x,n);}
\NormalTok{\}}
\NormalTok{PII chinese_remainder_theorem(}\DataTypeTok{int} \NormalTok{x, }\DataTypeTok{int} \NormalTok{a, }\DataTypeTok{int} \NormalTok{y, }\DataTypeTok{int} \NormalTok{b) \{}
  \DataTypeTok{int} \NormalTok{s, t;}
  \DataTypeTok{int} \NormalTok{d = extended_euclid(x, y, s, t);}
  \KeywordTok{if} \NormalTok{(a%d != b%d) }\KeywordTok{return} \NormalTok{make_pair(}\DecValTok{0}\NormalTok{, -}\DecValTok{1}\NormalTok{);}
  \KeywordTok{return} \NormalTok{make_pair(mod(s*b*x+t*a*y,x*y)/d, x*y/d);}
\NormalTok{\}}
\NormalTok{PII chinese_remainder_theorem(}\DataTypeTok{const} \NormalTok{VI &x, }\DataTypeTok{const} \NormalTok{VI &a) \{}
  \NormalTok{PII ret = make_pair(a[}\DecValTok{0}\NormalTok{], x[}\DecValTok{0}\NormalTok{]);}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{1}\NormalTok{; i < x.size(); i++) \{}
    \NormalTok{ret = chinese_remainder_theorem(ret.second, ret.first, x[i], a[i]);}
    \KeywordTok{if} \NormalTok{(ret.second == -}\DecValTok{1}\NormalTok{) }\KeywordTok{break}\NormalTok{;}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{ret;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{linear_diophantine(}\DataTypeTok{int} \NormalTok{a, }\DataTypeTok{int} \NormalTok{b, }\DataTypeTok{int} \NormalTok{c, }\DataTypeTok{int} \NormalTok{&x, }\DataTypeTok{int} \NormalTok{&y) \{}
  \DataTypeTok{int} \NormalTok{d = gcd(a,b);}
  \KeywordTok{if} \NormalTok{(c%d) \{}
    \NormalTok{x = y = -}\DecValTok{1}\NormalTok{;}
  \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \NormalTok{x = c/d * mod_inverse(a/d, b/d);}
    \NormalTok{y = (c-a*x)/b;}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Gaussian elimination}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{i,j,k;}
\DataTypeTok{int} \NormalTok{N,M;}
\DataTypeTok{double} \NormalTok{A[}\DecValTok{303}\NormalTok{][}\DecValTok{303}\NormalTok{];}
\DataTypeTok{double} \NormalTok{X[}\DecValTok{303}\NormalTok{];}

\DataTypeTok{int} \NormalTok{main() \{}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{1}\NormalTok{;i<=N;++i) \{}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{j=}\DecValTok{1}\NormalTok{;j<=M}\DecValTok{+1}\NormalTok{;++j) \{}
      \NormalTok{scanf(}\StringTok{"%lf"}\NormalTok{,&A[i][j]);}
    \NormalTok{\}}
  \NormalTok{\}}
  \NormalTok{i=}\DecValTok{1}\NormalTok{,j=}\DecValTok{1}\NormalTok{;}
  \KeywordTok{while}\NormalTok{(i<=N && j<=M) \{}
    \KeywordTok{for}\NormalTok{(k=i;k<=N;++k)}
      \KeywordTok{if}\NormalTok{(A[k][j]<-EPS\textbar{}\textbar{}A[k][j]>EPS)}
        \KeywordTok{break}\NormalTok{;}
    \KeywordTok{if}\NormalTok{(k==N}\DecValTok{+1}\NormalTok{) \{}
      \NormalTok{++j;}
      \KeywordTok{continue}\NormalTok{;}
    \NormalTok{\}}
    \KeywordTok{if}\NormalTok{(k!=i) \{}
      \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{q=}\DecValTok{1}\NormalTok{;q<=M}\DecValTok{+1}\NormalTok{;++q) \{}
        \DataTypeTok{double} \NormalTok{aux = A[i][q];}
        \NormalTok{A[i][q]= A[k][q];}
        \NormalTok{A[k][q]= aux;}
      \NormalTok{\}}
    \NormalTok{\}}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{q=j}\DecValTok{+1}\NormalTok{;q<=M}\DecValTok{+1}\NormalTok{;++q) \{}
      \NormalTok{A[i][q]=A[i][q]/A[i][j];}
    \NormalTok{\}}
    \NormalTok{A[i][j]=}\DecValTok{1}\NormalTok{;}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{u=i}\DecValTok{+1}\NormalTok{;u<=N;++u) \{}
      \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{q=j}\DecValTok{+1}\NormalTok{;q<=M}\DecValTok{+1}\NormalTok{;++q) \{}
        \NormalTok{A[u][q]-=A[u][j]*A[i][q];}
      \NormalTok{\}}
      \NormalTok{A[u][j]=}\DecValTok{0}\NormalTok{;}
    \NormalTok{\}}
    \NormalTok{++i;++j;}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Strings}

\subsection{Knuth-Morris-Pratt}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> prefix(}\DataTypeTok{const} \NormalTok{string& str) \{}
  \NormalTok{vector<}\DataTypeTok{int}\NormalTok{> pi(str.size(), }\DecValTok{0}\NormalTok{);}
  \DataTypeTok{int} \NormalTok{k = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{1}\NormalTok{; i < str.size(); ++i) \{}
    \KeywordTok{while} \NormalTok{(k > }\DecValTok{0} \NormalTok{&& str[i] != str[k])}
      \NormalTok{k = pi[k - }\DecValTok{1}\NormalTok{];}
    \KeywordTok{if} \NormalTok{(str[i] == str[k])}
      \NormalTok{++k;}
    \NormalTok{pi[i] = k;}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{pi;}
\NormalTok{\}}
\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> match(}\DataTypeTok{const} \NormalTok{string& str, }\DataTypeTok{const} \NormalTok{string& patt) \{}
  \NormalTok{vector<}\DataTypeTok{int}\NormalTok{> matches;}
  \NormalTok{vector<}\DataTypeTok{int}\NormalTok{> pi = prefix(patt);}
  \DataTypeTok{int} \NormalTok{k = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < str.size(); ++i) \{}
    \KeywordTok{while} \NormalTok{(k > }\DecValTok{0} \NormalTok{&& str[i] != patt[k])}
      \NormalTok{k = pi[k - }\DecValTok{1}\NormalTok{];}
    \KeywordTok{if} \NormalTok{(str[i] == patt[k])}
      \NormalTok{++k;}
    \KeywordTok{if} \NormalTok{(k == patt.size())}
      \NormalTok{matches.push_back(i - patt.size() + }\DecValTok{1}\NormalTok{);}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{matches;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Rabin-Karp}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{A[MAXN], B[MAXN];}
\DataTypeTok{int} \NormalTok{NA, NB;}
\DataTypeTok{int} \NormalTok{hashA1, hashA2, P1, P2;}
\DataTypeTok{char} \NormalTok{match[MAXN];}

\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{P1 = P2 = }\DecValTok{1}\NormalTok{;}
  \NormalTok{hashA1 = hashA2 = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < NA; i++) \{}
    \NormalTok{hashA1 = (hashA1 * P + A[i]) % MOD1;}
    \NormalTok{hashA2 = (hashA2 * P + A[i]) % MOD2;}
    \KeywordTok{if} \NormalTok{(i != }\DecValTok{0}\NormalTok{)}
      \NormalTok{P1 = (P1 * P) % MOD1,}
         \NormalTok{P2 = (P2 * P) % MOD2;}
  \NormalTok{\}}
  \DataTypeTok{int} \NormalTok{hash1 = }\DecValTok{0}\NormalTok{, hash2 = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < NA; i++)}
    \NormalTok{hash1 = (hash1 * P + B[i]) % MOD1,}
          \NormalTok{hash2 = (hash2 * P + B[i]) % MOD2;}
  \DataTypeTok{int} \NormalTok{Nr = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{if} \NormalTok{(hash1 == hashA1 && hash2 == hashA2)}
    \NormalTok{match[}\DecValTok{0}\NormalTok{] = }\DecValTok{1}\NormalTok{, Nr++;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = NA; i < NB; i++) \{}
    \NormalTok{hash1 = ((hash1 - (B[i - NA] * P1) % MOD1 + MOD1) * P + B[i]) % MOD1;}
    \NormalTok{hash2 = ((hash2 - (B[i - NA] * P2) % MOD2 + MOD2) * P + B[i]) % MOD2;}
    \KeywordTok{if} \NormalTok{(hash1 == hashA1 && hash2 == hashA2)}
      \NormalTok{match[ i - NA + }\DecValTok{1} \NormalTok{] = }\DecValTok{1}\NormalTok{, Nr++;}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Longest palindromic substring}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{N;}
\DataTypeTok{char} \NormalTok{s[MAXN];}
\DataTypeTok{int} \NormalTok{dp[}\DecValTok{2}\NormalTok{][MAXN];}
\DataTypeTok{long} \DataTypeTok{long} \NormalTok{res = }\DecValTok{0}\NormalTok{;}

\DataTypeTok{int} \NormalTok{explode(}\DataTypeTok{int} \NormalTok{l, }\DataTypeTok{int} \NormalTok{r) \{}
  \DataTypeTok{int} \NormalTok{len = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(; l >= }\DecValTok{0} \NormalTok{&& r < N && s[l] == s[r]; --l, ++r, ++len);}
  \KeywordTok{return} \NormalTok{len;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{odd_center() \{}
  \DataTypeTok{int} \NormalTok{last = -}\DecValTok{1}\NormalTok{, right = -}\DecValTok{1}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < N; ++i) \{}
    \KeywordTok{if} \NormalTok{(right >= i)}
      \NormalTok{dp[}\DecValTok{0}\NormalTok{][i] = min(dp[}\DecValTok{0}\NormalTok{][}\DecValTok{2} \NormalTok{* last - i], right - i);}

    \DataTypeTok{int} \NormalTok{l = i - dp[}\DecValTok{0}\NormalTok{][i];}
    \DataTypeTok{int} \NormalTok{r = i + dp[}\DecValTok{0}\NormalTok{][i];}
    \NormalTok{dp[}\DecValTok{0}\NormalTok{][i] += explode(l, r);}
    \KeywordTok{if} \NormalTok{(i + dp[}\DecValTok{0}\NormalTok{][i] > right) \{}
      \NormalTok{last = i;}
      \NormalTok{right = i + dp[}\DecValTok{0}\NormalTok{][i];}
    \NormalTok{\}}
    \NormalTok{res += (}\DataTypeTok{long} \DataTypeTok{long}\NormalTok{) dp[}\DecValTok{0}\NormalTok{][i];}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{even_center() \{}
  \DataTypeTok{int} \NormalTok{last = -}\DecValTok{1}\NormalTok{, right = -}\DecValTok{1}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < N; ++i) \{}
    \KeywordTok{if} \NormalTok{(s[i] != s[i + }\DecValTok{1}\NormalTok{])}
      \KeywordTok{continue}\NormalTok{;}
    \KeywordTok{if} \NormalTok{(right > i)}
      \NormalTok{dp[}\DecValTok{1}\NormalTok{][i] = min(dp[}\DecValTok{1}\NormalTok{][}\DecValTok{2} \NormalTok{* last - i], right - i - }\DecValTok{1}\NormalTok{);}
    \DataTypeTok{int} \NormalTok{l = i - dp[}\DecValTok{1}\NormalTok{][i];}
    \DataTypeTok{int} \NormalTok{r = i + dp[}\DecValTok{1}\NormalTok{][i] + }\DecValTok{1}\NormalTok{;}
    \NormalTok{dp[}\DecValTok{1}\NormalTok{][i] += explode(l, r);}
    \KeywordTok{if} \NormalTok{(i + dp[}\DecValTok{1}\NormalTok{][i] + }\DecValTok{1} \NormalTok{> right) \{}
      \NormalTok{last = i;}
      \NormalTok{right = i + dp[}\DecValTok{1}\NormalTok{][i] + }\DecValTok{1}\NormalTok{;}
    \NormalTok{\}}
    \NormalTok{res += (}\DataTypeTok{long} \DataTypeTok{long}\NormalTok{) dp[}\DecValTok{1}\NormalTok{][i];}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{odd_center();}
  \NormalTok{even_center();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Trie}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Trie \{}
  \DataTypeTok{int} \NormalTok{cnt, nrsons;}
  \NormalTok{Trie *son[}\DecValTok{26}\NormalTok{];}

  \NormalTok{Trie() \{}
    \NormalTok{cnt = nrsons = }\DecValTok{0}\NormalTok{;}
    \NormalTok{memset(son, }\DecValTok{0}\NormalTok{, }\KeywordTok{sizeof}\NormalTok{(son));}
  \NormalTok{\}}
\NormalTok{\};}

\NormalTok{Trie *T = }\KeywordTok{new} \NormalTok{Trie;}
\DataTypeTok{void} \NormalTok{ins(Trie *node, }\DataTypeTok{char} \NormalTok{*s) \{}
  \KeywordTok{if} \NormalTok{(*s == '\textbackslash{}}\DecValTok{0}\NormalTok{') \{}
    \NormalTok{node->cnt++;}
    \KeywordTok{return}\NormalTok{;}
  \NormalTok{\}}
  \KeywordTok{if} \NormalTok{(node->son[ch] == }\DecValTok{0}\NormalTok{) \{}
    \NormalTok{node->son[ch] = }\KeywordTok{new} \NormalTok{Trie;}
    \NormalTok{node->nrsons++;}
  \NormalTok{\}}
  \NormalTok{ins(node->son[ch], s + }\DecValTok{1}\NormalTok{);}
\NormalTok{\}}

\DataTypeTok{int} \NormalTok{del(Trie *node, }\DataTypeTok{char} \NormalTok{*s) \{}
  \KeywordTok{if} \NormalTok{(*s == '\textbackslash{}}\DecValTok{0}\NormalTok{')}
    \NormalTok{node->cnt--;}
  \KeywordTok{else} \KeywordTok{if} \NormalTok{(del(node->son[ch], s + }\DecValTok{1}\NormalTok{)) \{}
    \NormalTok{node->son[ch] = }\DecValTok{0}\NormalTok{;}
    \NormalTok{node->nrsons--;}
  \NormalTok{\}}
  \KeywordTok{if} \NormalTok{(node->cnt == }\DecValTok{0} \NormalTok{&& node->nrsons == }\DecValTok{0} \NormalTok{&& node != T) \{}
    \KeywordTok{delete} \NormalTok{node;}
    \KeywordTok{return} \DecValTok{1}\NormalTok{;}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{freq(Trie *node, }\DataTypeTok{char} \NormalTok{*s) \{}
  \KeywordTok{if} \NormalTok{(*s == '\textbackslash{}}\DecValTok{0}\NormalTok{')}
    \KeywordTok{return} \NormalTok{node->cnt;}
  \KeywordTok{if} \NormalTok{(node->son[ch])}
    \KeywordTok{return} \NormalTok{freq(node->son[ch], s + }\DecValTok{1}\NormalTok{);}
  \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{pref(Trie *node, }\DataTypeTok{char} \NormalTok{*s, }\DataTypeTok{int} \NormalTok{k) \{}
  \KeywordTok{if} \NormalTok{(*s == '\textbackslash{}}\DecValTok{0}\NormalTok{' \textbar{}\textbar{} node->son[ch] == }\DecValTok{0}\NormalTok{)}
    \KeywordTok{return} \NormalTok{k;}
  \KeywordTok{return} \NormalTok{pref(node->son[ch], s + }\DecValTok{1}\NormalTok{, k + }\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Geometry}

\subsection{Convex hull}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \NormalTok{pair<}\DataTypeTok{double}\NormalTok{, }\DataTypeTok{double}\NormalTok{> point;}

\DataTypeTok{int} \NormalTok{n;}
\NormalTok{point v[MAXN];}
\DataTypeTok{int} \NormalTok{head;}
\NormalTok{point stack[MAXN];}

\KeywordTok{inline} \DataTypeTok{double} \NormalTok{cross_prod(}\DataTypeTok{const} \NormalTok{point& A, }\DataTypeTok{const} \NormalTok{point& B, }\DataTypeTok{const} \NormalTok{point& C) \{}
  \KeywordTok{return} \NormalTok{(B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{bool} \NormalTok{comp(}\DataTypeTok{const} \NormalTok{point& A, }\DataTypeTok{const} \NormalTok{point& B) \{}
  \KeywordTok{return} \NormalTok{cross_prod(v[}\DecValTok{1}\NormalTok{], A, B) < }\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{sort_points() \{}
  \DataTypeTok{int} \NormalTok{pos = }\DecValTok{1}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{2}\NormalTok{; i <= n; ++i)}
    \KeywordTok{if} \NormalTok{(v[i] < v[pos])}
      \NormalTok{pos = i;}
  \NormalTok{swap(v[}\DecValTok{1}\NormalTok{], v[pos]);}
  \NormalTok{sort(v + }\DecValTok{2}\NormalTok{, v + n + }\DecValTok{1}\NormalTok{, comp);}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{convex_hull() \{}
  \NormalTok{sort_points();}

  \NormalTok{stack[}\DecValTok{1}\NormalTok{] = v[}\DecValTok{1}\NormalTok{];}
  \NormalTok{stack[}\DecValTok{2}\NormalTok{] = v[}\DecValTok{2}\NormalTok{];}
  \NormalTok{head = }\DecValTok{2}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{3}\NormalTok{; i <= n; ++i) \{}
    \KeywordTok{while} \NormalTok{(head >= }\DecValTok{2} \NormalTok{&& cross_prod(stack[head - }\DecValTok{1}\NormalTok{], stack[head], v[i]) > }\DecValTok{0}\NormalTok{)}
      \NormalTok{--head;}
    \NormalTok{stack[++head] = v[i];}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Miscellaneous geometry}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{point \{}
  \DataTypeTok{double} \NormalTok{x, y;}
  \NormalTok{point() \{\}}
  \NormalTok{point(}\DataTypeTok{double} \NormalTok{x_, }\DataTypeTok{double} \NormalTok{y_): x(x_), y(y_) \{\}}
  \NormalTok{point(}\DataTypeTok{const} \NormalTok{point& p): x(p.x), y(p.y) \{\}}

  \NormalTok{point }\KeywordTok{operator}\NormalTok{+(}\DataTypeTok{const} \NormalTok{point& p) }\DataTypeTok{const} \NormalTok{\{ }\KeywordTok{return} \NormalTok{point(x + p.x, y + p.y); \}}
  \NormalTok{point }\KeywordTok{operator}\NormalTok{-(}\DataTypeTok{const} \NormalTok{point& p) }\DataTypeTok{const} \NormalTok{\{ }\KeywordTok{return} \NormalTok{point(x - p.x, y - p.y); \}}
  \NormalTok{point }\KeywordTok{operator}\NormalTok{*(}\DataTypeTok{double} \NormalTok{c) }\DataTypeTok{const} \NormalTok{\{ }\KeywordTok{return} \NormalTok{point(x * c, y * c); \}}
  \NormalTok{point }\KeywordTok{operator}\NormalTok{/(}\DataTypeTok{double} \NormalTok{c) }\DataTypeTok{const} \NormalTok{\{ }\KeywordTok{return} \NormalTok{point(x / c, y / c); \}}
\NormalTok{\};}
\NormalTok{ostream &}\KeywordTok{operator}\NormalTok{<<(ostream &os, }\DataTypeTok{const} \NormalTok{point& p) \{}
  \NormalTok{os << }\StringTok{"("} \NormalTok{<< p.x << }\StringTok{","} \NormalTok{<< p.y << }\StringTok{")"}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{double} \NormalTok{dot(point p, point q) \{ }\KeywordTok{return} \NormalTok{p.x * q.x + p.y * q.y; \}}
\DataTypeTok{double} \NormalTok{dist2(point p, point q) \{ }\KeywordTok{return} \NormalTok{dot(p - q, p - q); \}}
\DataTypeTok{double} \NormalTok{dist(point p, point q) \{ }\KeywordTok{return} \NormalTok{sqrt(dist2(p, q)); \}}
\DataTypeTok{double} \NormalTok{cross(point p, point q) \{ }\KeywordTok{return} \NormalTok{p.x * q.y - p.y * q.x; \}}

\DataTypeTok{double} \NormalTok{is_left(point a, point b, point c) \{}
  \KeywordTok{return} \NormalTok{cross(b - a, c - a);}
\NormalTok{\}}

\NormalTok{point rotate_cw_90(point p) \{ }\KeywordTok{return} \NormalTok{point(p.y, -p.x); \}}
\NormalTok{point rotate_ccw_90(point p) \{ }\KeywordTok{return} \NormalTok{point(-p.y, p.x); \}}
\NormalTok{point rotate(point p, }\DataTypeTok{double} \NormalTok{a) \{}
  \KeywordTok{return} \NormalTok{point(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));}
\NormalTok{\}}

\NormalTok{point project_point_line(point a, point b, point c) \{}
  \KeywordTok{return} \NormalTok{a + (b - a) * dot(c - a, b - a) / dot(b - a, b - a);}
\NormalTok{\}}
\NormalTok{point project_point_segment(point a, point b, point c) \{}
  \DataTypeTok{double} \NormalTok{d = dot(b - a, b - a);}
  \KeywordTok{if} \NormalTok{(abs(d) < EPS) }\KeywordTok{return} \NormalTok{a;}
  \NormalTok{d = dot(c - a, b - a) / d;}
  \KeywordTok{if} \NormalTok{(d < }\DecValTok{0}\NormalTok{) }\KeywordTok{return} \NormalTok{a;}
  \KeywordTok{if} \NormalTok{(d > }\DecValTok{1}\NormalTok{) }\KeywordTok{return} \NormalTok{b;}
  \KeywordTok{return} \NormalTok{a + (b - a) * d;}
\NormalTok{\}}

\DataTypeTok{double} \NormalTok{distance_point_segment(point a, point b, point c) \{}
  \KeywordTok{return} \NormalTok{sqrt(dist2(c, project_point_segment(a, b, c)));}
\NormalTok{\}}
\DataTypeTok{double} \NormalTok{distance_point_plane(}\DataTypeTok{double} \NormalTok{x, }\DataTypeTok{double} \NormalTok{y, }\DataTypeTok{double} \NormalTok{z,}
    \DataTypeTok{double} \NormalTok{a, }\DataTypeTok{double} \NormalTok{b, }\DataTypeTok{double} \NormalTok{c, }\DataTypeTok{double} \NormalTok{d) \{}
  \KeywordTok{return} \NormalTok{abs(a * x + b * y + c * z - d) / sqrt(a * a + b * b + c * c);}
\NormalTok{\}}

\DataTypeTok{bool} \NormalTok{lines_parallel(point a, point b, point c, point d) \{}
  \KeywordTok{return} \NormalTok{abs(cross(b - a, c - d)) < EPS;}
\NormalTok{\}}
\DataTypeTok{bool} \NormalTok{lines_collinear(point a, point b, point c, point d) \{}
  \KeywordTok{return} \NormalTok{lines_parallel(a, b, c, d) &&}
    \NormalTok{abs(cross(a - b, a - c)) < EPS &&}
    \NormalTok{abs(cross(c - d, c - a)) < EPS;}
\NormalTok{\}}

\DataTypeTok{bool} \NormalTok{segments_intersect(point a, point b, point c, point d) \{}
  \KeywordTok{if} \NormalTok{(lines_collinear(a, b, c, d)) \{}
    \KeywordTok{if} \NormalTok{(dist2(a, c) < EPS \textbar{}\textbar{} dist2(a, d) < EPS \textbar{}\textbar{}}
        \NormalTok{dist2(b, c) < EPS \textbar{}\textbar{} dist2(b, d) < EPS) }\KeywordTok{return} \KeywordTok{true}\NormalTok{;}
    \KeywordTok{if} \NormalTok{(dot(c - a, c - b) > }\DecValTok{0} \NormalTok{&& dot(d - a, d - b) > }\DecValTok{0} \NormalTok{&&}
        \NormalTok{dot(c - b, d - b) > }\DecValTok{0}\NormalTok{) }\KeywordTok{return} \KeywordTok{false}\NormalTok{;}
    \KeywordTok{return} \KeywordTok{true}\NormalTok{;}
  \NormalTok{\}}
  \KeywordTok{if} \NormalTok{(cross(d - a, b - a) * cross(c - a, b - a) > }\DecValTok{0}\NormalTok{) }\KeywordTok{return} \KeywordTok{false}\NormalTok{;}
  \KeywordTok{if} \NormalTok{(cross(a - c, d - c) * cross(b - c, d - c) > }\DecValTok{0}\NormalTok{) }\KeywordTok{return} \KeywordTok{false}\NormalTok{;}
  \KeywordTok{return} \KeywordTok{true}\NormalTok{;}
\NormalTok{\}}
\NormalTok{point compute_line_intersection(point a, point b, point c, point d) \{}
  \NormalTok{b = b - a; d = c - d; c = c - a;}
  \KeywordTok{return} \NormalTok{a + b * cross(c, d) / cross(b, d);}
\NormalTok{\}}
\NormalTok{point compute_circle_center(point a, point b, point c) \{}
  \NormalTok{b = (a + b) / }\DecValTok{2}\NormalTok{;}
  \NormalTok{c = (a + c) / }\DecValTok{2}\NormalTok{;}
  \KeywordTok{return} \NormalTok{compute_line_intersection(b, b + rotate_cw_90(a - b),}
      \NormalTok{c, c + rotate_cw_90(a - c));}
\NormalTok{\}}

\DataTypeTok{bool} \NormalTok{point_in_poly(point p, }\DataTypeTok{const} \NormalTok{vector<point>& v) \{}
  \DataTypeTok{int} \NormalTok{wn = }\DecValTok{0}\NormalTok{;}
  \DataTypeTok{int} \NormalTok{n = }\KeywordTok{static_cast}\NormalTok{<}\DataTypeTok{int}\NormalTok{>(v.size());}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \DataTypeTok{int} \NormalTok{j = (i + }\DecValTok{1}\NormalTok{) % n;}
    \KeywordTok{if} \NormalTok{(v[i].y <= p.y) \{}
      \KeywordTok{if} \NormalTok{(v[j].y > p.y && is_left(v[i], v[j], p) > }\DecValTok{0}\NormalTok{)}
        \NormalTok{++wn;}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
      \KeywordTok{if} \NormalTok{(v[j].y <= p.y && is_left(v[i], v[j], p) < }\DecValTok{0}\NormalTok{)}
        \NormalTok{--wn;}
    \NormalTok{\}}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{wn != }\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{bool} \NormalTok{point_on_polygon(point p, }\DataTypeTok{const} \NormalTok{vector<point>& v) \{}
  \DataTypeTok{int} \NormalTok{n = }\KeywordTok{static_cast}\NormalTok{<}\DataTypeTok{int}\NormalTok{>(v.size());}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \DataTypeTok{int} \NormalTok{j = (i + }\DecValTok{1}\NormalTok{) % n;}
    \KeywordTok{if} \NormalTok{(dist2(project_point_segment(v[i], v[j], p), p) < EPS)}
      \KeywordTok{return} \KeywordTok{true}\NormalTok{;}
  \NormalTok{\}}
  \KeywordTok{return} \KeywordTok{false}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{double} \NormalTok{signed_area(}\DataTypeTok{const} \NormalTok{vector<point>& v) \{}
  \DataTypeTok{int} \NormalTok{n = }\KeywordTok{static_cast}\NormalTok{<}\DataTypeTok{int}\NormalTok{>(v.size());}
  \DataTypeTok{double} \NormalTok{area = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \DataTypeTok{int} \NormalTok{j = (i + }\DecValTok{1}\NormalTok{) % n;}
    \NormalTok{area += v[i].x * v[j].y - v[j].x * v[i].y;}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{area / }\FloatTok{2.0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{double} \NormalTok{area(}\DataTypeTok{const} \NormalTok{vector<point>& v) \{}
  \KeywordTok{return} \NormalTok{abs(signed_area(v));}
\NormalTok{\}}
\NormalTok{point centroid(}\DataTypeTok{const} \NormalTok{vector<point>& v) \{}
  \DataTypeTok{int} \NormalTok{n = }\KeywordTok{static_cast}\NormalTok{<}\DataTypeTok{int}\NormalTok{>(v.size());}
  \NormalTok{point c(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{);}
  \DataTypeTok{double} \NormalTok{scale = }\FloatTok{6.0} \NormalTok{* signed_area(v);}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \DataTypeTok{int} \NormalTok{j = (i + }\DecValTok{1}\NormalTok{) % n;}
    \NormalTok{c = c + (v[i] + v[j]) * (v[i].x * v[j].y - v[j].x * v[i].y);}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{c / scale;}
\NormalTok{\}}
\DataTypeTok{bool} \NormalTok{is_simple(}\DataTypeTok{const} \NormalTok{vector<point>& v) \{}
  \DataTypeTok{int} \NormalTok{n = }\KeywordTok{static_cast}\NormalTok{<}\DataTypeTok{int}\NormalTok{>(v.size());}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{k = i + }\DecValTok{1}\NormalTok{; k < n; ++k) \{}
      \DataTypeTok{int} \NormalTok{j = (i + }\DecValTok{1}\NormalTok{) % n;}
      \DataTypeTok{int} \NormalTok{l = (k + }\DecValTok{1}\NormalTok{) % n;}
      \KeywordTok{if} \NormalTok{(i == l \textbar{}\textbar{} j == k) }\KeywordTok{continue}\NormalTok{;}
      \KeywordTok{if} \NormalTok{(segments_intersect(v[i], v[j], v[k], v[l]))}
        \KeywordTok{return} \KeywordTok{false}\NormalTok{;}
    \NormalTok{\}}
  \NormalTok{\}}
  \KeywordTok{return} \KeywordTok{true}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Other}

\subsection{2SAT}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> g[}\DecValTok{202020}\NormalTok{],gx[}\DecValTok{202020}\NormalTok{],last,stackx,viz,iss,low,aux,tare,gr_in;}
\NormalTok{vector<vector<}\DataTypeTok{int}\NormalTok{> > comp;}
\DataTypeTok{int} \NormalTok{N,index=}\DecValTok{1}\NormalTok{,k,Nn,M,x,y;}
\DataTypeTok{int} \NormalTok{rez[}\DecValTok{201010}\NormalTok{];}
\DataTypeTok{int} \NormalTok{notn(}\DataTypeTok{int} \NormalTok{x)\{}
  \KeywordTok{if}\NormalTok{(x<=N)\{}
    \KeywordTok{return} \NormalTok{x + N;}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{x-N;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{df(}\DataTypeTok{int} \NormalTok{x)\{}
  \NormalTok{viz[x] = index;}
  \NormalTok{low[x] = index;}
  \NormalTok{stackx[++k] = x;}
  \NormalTok{iss[x] = }\DecValTok{1}\NormalTok{;}
  \NormalTok{++index;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<g[x].size();++i)\{}
    \KeywordTok{if}\NormalTok{(viz[g[x][i]] == }\DecValTok{0}\NormalTok{)\{}
      \NormalTok{df(g[x][i]);}
      \NormalTok{low[x] = min(low[x],low[g[x][i]]);}
    \NormalTok{\} }\KeywordTok{else}\NormalTok{\{}
      \KeywordTok{if}\NormalTok{(iss[g[x][i]])\{}
        \NormalTok{low[x] = min(low[x],low[g[x][i]]);}
      \NormalTok{\}}
    \NormalTok{\}}
  \NormalTok{\}}
  \KeywordTok{if}\NormalTok{(low[x] == viz[x])\{}
    \NormalTok{aux.clear();}
    \KeywordTok{do}\NormalTok{\{}
      \NormalTok{aux.pb(stackx[k]);}
      \NormalTok{iss[stackx[k]] = }\DecValTok{0}\NormalTok{;}
      \NormalTok{--k;}
    \NormalTok{\}}\KeywordTok{while}\NormalTok{(stackx[k}\DecValTok{+1}\NormalTok{] != x);}
    \NormalTok{comp.pb(aux);}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{init()\{}
  \NormalTok{index = }\DecValTok{1}\NormalTok{;}
  \NormalTok{stackx.resize(Nn}\DecValTok{+10}\NormalTok{);}
  \NormalTok{viz.resize(Nn}\DecValTok{+10}\NormalTok{);}
  \NormalTok{iss.resize(Nn}\DecValTok{+10}\NormalTok{);}
  \NormalTok{low.resize(Nn}\DecValTok{+10}\NormalTok{);}
  \NormalTok{tare.resize(Nn}\DecValTok{+10}\NormalTok{);}
  \NormalTok{last.resize(Nn}\DecValTok{+10}\NormalTok{);}
  \NormalTok{gr_in.resize(Nn}\DecValTok{+10}\NormalTok{);}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{make_ctc()\{}
  \NormalTok{Nn=}\DecValTok{2}\NormalTok{*N;}
  \NormalTok{init();}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{1}\NormalTok{;i<=Nn;++i)\{}
    \KeywordTok{if}\NormalTok{(viz[i]==}\DecValTok{0}\NormalTok{)\{}
      \NormalTok{df(i);}
    \NormalTok{\}}
  \NormalTok{\}}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<comp.size();++i)\{}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{j=}\DecValTok{0}\NormalTok{;j<comp[i].size();++j)\{}
      \NormalTok{tare[comp[i][j]] = i}\DecValTok{+1}\NormalTok{;}
    \NormalTok{\}}
  \NormalTok{\}}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{solve()\{}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{1}\NormalTok{;i<=N;++i)\{}
    \KeywordTok{if}\NormalTok{(tare[i] == tare[notn(i)])\{}
      \NormalTok{printf(}\StringTok{"-1}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
      \KeywordTok{return}\NormalTok{;}
    \NormalTok{\}}
  \NormalTok{\}}
  \DataTypeTok{int} \NormalTok{nod;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<comp.size();++i)\{}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{j=}\DecValTok{0}\NormalTok{;j<comp[i].size();++j)\{}
      \NormalTok{nod = comp[i][j];}
      \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{k=}\DecValTok{0}\NormalTok{;k<g[nod].size();++k)\{}
        \DataTypeTok{int} \NormalTok{compv = tare[g[nod][k]];}
        \KeywordTok{if} \NormalTok{( last[compv] != i}\DecValTok{+1} \NormalTok{&& compv != i}\DecValTok{+1} \NormalTok{)\{}
          \NormalTok{gx[i}\DecValTok{+1}\NormalTok{].pb(compv);}
          \NormalTok{++gr_in[compv];}
          \NormalTok{last[compv]=i}\DecValTok{+1}\NormalTok{;}
        \NormalTok{\}}
      \NormalTok{\}}
    \NormalTok{\}}
  \NormalTok{\}}
  \NormalTok{queue<}\DataTypeTok{int}\NormalTok{> Q;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{1}\NormalTok{;i<=comp.size();++i)\{}
    \KeywordTok{if}\NormalTok{(gr_in[i]==}\DecValTok{0}\NormalTok{)\{}
      \NormalTok{Q.push(i);}
    \NormalTok{\}}
  \NormalTok{\}}
  \DataTypeTok{int} \NormalTok{nr = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{while}\NormalTok{(!Q.empty())\{}
    \NormalTok{++nr;}
    \NormalTok{nod = Q.front(); Q.pop();}
    \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<gx[nod].size();++i)\{}
      \DataTypeTok{int} \NormalTok{nodv = gx[nod][i];}
      \NormalTok{--gr_in[nodv];}
      \KeywordTok{if} \NormalTok{(gr_in[nodv]==}\DecValTok{0}\NormalTok{)}
        \NormalTok{Q.push(nodv);}
    \NormalTok{\}}
    \KeywordTok{if} \NormalTok{( last[nod] == -}\DecValTok{1} \NormalTok{)  }\KeywordTok{continue} \NormalTok{;}
    \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i=}\DecValTok{0}\NormalTok{;i<comp[nod}\DecValTok{-1}\NormalTok{].size();++i)\{}
      \NormalTok{rez[comp[nod}\DecValTok{-1}\NormalTok{][i]] = }\DecValTok{0}\NormalTok{;}
      \NormalTok{rez[notn(comp[nod}\DecValTok{-1}\NormalTok{][i])] = }\DecValTok{1}\NormalTok{;}
    \NormalTok{\}}
    \NormalTok{nod = tare[notn(comp[nod}\DecValTok{-1}\NormalTok{][}\DecValTok{0}\NormalTok{])];}
    \NormalTok{last[nod] = -}\DecValTok{1}\NormalTok{;}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{KD-tree}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \NormalTok{ntype sentry = numeric_limits<ntype>::max();}
\KeywordTok{struct} \NormalTok{point \{}
  \NormalTok{ntype x, y;}
  \NormalTok{point(ntype xx = }\DecValTok{0}\NormalTok{, ntype yy = }\DecValTok{0}\NormalTok{) : x(xx), y(yy) \{\}}
\NormalTok{\};}
\DataTypeTok{bool} \KeywordTok{operator}\NormalTok{==(}\DataTypeTok{const} \NormalTok{point &a, }\DataTypeTok{const} \NormalTok{point &b) \{}
  \KeywordTok{return} \NormalTok{a.x == b.x && a.y == b.y;}
\NormalTok{\}}
\DataTypeTok{bool} \NormalTok{on_x(}\DataTypeTok{const} \NormalTok{point &a, }\DataTypeTok{const} \NormalTok{point &b) \{}
  \KeywordTok{return} \NormalTok{a.x < b.x;}
\NormalTok{\}}
\DataTypeTok{bool} \NormalTok{on_y(}\DataTypeTok{const} \NormalTok{point &a, }\DataTypeTok{const} \NormalTok{point &b) \{}
  \KeywordTok{return} \NormalTok{a.y < b.y;}
\NormalTok{\}}
\NormalTok{ntype pdist2(}\DataTypeTok{const} \NormalTok{point &a, }\DataTypeTok{const} \NormalTok{point &b) \{}
  \NormalTok{ntype dx = a.x-b.x, dy = a.y-b.y;}
  \KeywordTok{return} \NormalTok{dx*dx + dy*dy;}
\NormalTok{\}}
\KeywordTok{struct} \NormalTok{bbox \{}
  \NormalTok{ntype x0, x1, y0, y1;}
  \NormalTok{bbox() : x0(sentry), x1(-sentry), y0(sentry), y1(-sentry) \{\}}
  \DataTypeTok{void} \NormalTok{compute(}\DataTypeTok{const} \NormalTok{vector<point> &v) \{}
    \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < v.size(); ++i) \{}
      \NormalTok{x0 = min(x0, v[i].x);   x1 = max(x1, v[i].x);}
      \NormalTok{y0 = min(y0, v[i].y);   y1 = max(y1, v[i].y);}
    \NormalTok{\}}
  \NormalTok{\}}
  \NormalTok{ntype distance(}\DataTypeTok{const} \NormalTok{point &p) \{}
    \KeywordTok{if} \NormalTok{(p.x < x0) \{}
      \KeywordTok{if} \NormalTok{(p.y < y0)       }\KeywordTok{return} \NormalTok{pdist2(point(x0, y0), p);}
      \KeywordTok{else} \KeywordTok{if} \NormalTok{(p.y > y1)  }\KeywordTok{return} \NormalTok{pdist2(point(x0, y1), p);}
      \KeywordTok{else}                \KeywordTok{return} \NormalTok{pdist2(point(x0, p.y), p);}
    \NormalTok{\} }\KeywordTok{else} \KeywordTok{if} \NormalTok{(p.x > x1) \{}
      \KeywordTok{if} \NormalTok{(p.y < y0)       }\KeywordTok{return} \NormalTok{pdist2(point(x1, y0), p);}
      \KeywordTok{else} \KeywordTok{if} \NormalTok{(p.y > y1)  }\KeywordTok{return} \NormalTok{pdist2(point(x1, y1), p);}
      \KeywordTok{else}                \KeywordTok{return} \NormalTok{pdist2(point(x1, p.y), p);}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
      \KeywordTok{if} \NormalTok{(p.y < y0)       }\KeywordTok{return} \NormalTok{pdist2(point(p.x, y0), p);}
      \KeywordTok{else} \KeywordTok{if} \NormalTok{(p.y > y1)  }\KeywordTok{return} \NormalTok{pdist2(point(p.x, y1), p);}
      \KeywordTok{else}                \KeywordTok{return} \DecValTok{0}\NormalTok{;}
    \NormalTok{\}}
  \NormalTok{\}}
\NormalTok{\};}
\KeywordTok{struct} \NormalTok{kdnode \{}
  \DataTypeTok{bool} \NormalTok{leaf;      }\CommentTok{// true if this is a leaf node (has one point)}
  \NormalTok{point pt;       }\CommentTok{// the single point of this is a leaf}
  \NormalTok{bbox bound;     }\CommentTok{// bounding box for set of points in children}

  \NormalTok{kdnode *first, *second; }\CommentTok{// two children of this kd-node}

  \NormalTok{kdnode() : leaf(}\KeywordTok{false}\NormalTok{), first(}\DecValTok{0}\NormalTok{), second(}\DecValTok{0}\NormalTok{) \{\}}
  \NormalTok{~kdnode() \{ }\KeywordTok{if} \NormalTok{(first) }\KeywordTok{delete} \NormalTok{first; }\KeywordTok{if} \NormalTok{(second) }\KeywordTok{delete} \NormalTok{second; \}}

  \NormalTok{ntype intersect(}\DataTypeTok{const} \NormalTok{point &p) \{}
    \KeywordTok{return} \NormalTok{bound.distance(p);}
  \NormalTok{\}}
  \DataTypeTok{void} \NormalTok{construct(vector<point> &vp) \{}
    \NormalTok{bound.compute(vp);}
    \KeywordTok{if} \NormalTok{(vp.size() == }\DecValTok{1}\NormalTok{) \{}
      \NormalTok{leaf = }\KeywordTok{true}\NormalTok{;}
      \NormalTok{pt = vp[}\DecValTok{0}\NormalTok{];}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
      \KeywordTok{if} \NormalTok{(bound.x1-bound.x0 >= bound.y1-bound.y0)}
        \NormalTok{sort(vp.begin(), vp.end(), on_x);}
      \KeywordTok{else}
        \NormalTok{sort(vp.begin(), vp.end(), on_y);}

      \DataTypeTok{int} \NormalTok{half = vp.size()/}\DecValTok{2}\NormalTok{;}
      \NormalTok{vector<point> vl(vp.begin(), vp.begin()+half);}
      \NormalTok{vector<point> vr(vp.begin()+half, vp.end());}
      \NormalTok{first = }\KeywordTok{new} \NormalTok{kdnode();   first->construct(vl);}
      \NormalTok{second = }\KeywordTok{new} \NormalTok{kdnode();  second->construct(vr);}
    \NormalTok{\}}
  \NormalTok{\}}
\NormalTok{\};}

\KeywordTok{struct} \NormalTok{kdtree \{}
  \NormalTok{kdnode *root;}
  \NormalTok{kdtree(}\DataTypeTok{const} \NormalTok{vector<point> &vp) \{}
    \NormalTok{vector<point> v(vp.begin(), vp.end());}
    \NormalTok{root = }\KeywordTok{new} \NormalTok{kdnode();}
    \NormalTok{root->construct(v);}
  \NormalTok{\}}
  \NormalTok{~kdtree() \{ }\KeywordTok{delete} \NormalTok{root; \}}
  \NormalTok{ntype search(kdnode *node, }\DataTypeTok{const} \NormalTok{point &p) \{}
    \KeywordTok{if} \NormalTok{(node->leaf) \{}
      \KeywordTok{return} \NormalTok{pdist2(p, node->pt);}
    \NormalTok{\}}
    \NormalTok{ntype bfirst = node->first->intersect(p);}
    \NormalTok{ntype bsecond = node->second->intersect(p);}

    \KeywordTok{if} \NormalTok{(bfirst < bsecond) \{}
      \NormalTok{ntype best = search(node->first, p);}
      \KeywordTok{if} \NormalTok{(bsecond < best)}
        \NormalTok{best = min(best, search(node->second, p));}
      \KeywordTok{return} \NormalTok{best;}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
      \NormalTok{ntype best = search(node->second, p);}
      \KeywordTok{if} \NormalTok{(bfirst < best)}
        \NormalTok{best = min(best, search(node->first, p));}
      \KeywordTok{return} \NormalTok{best;}
    \NormalTok{\}}
  \NormalTok{\}}
  \NormalTok{ntype nearest(}\DataTypeTok{const} \NormalTok{point &p) \{}
    \KeywordTok{return} \NormalTok{search(root, p);}
  \NormalTok{\}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\end{document}
