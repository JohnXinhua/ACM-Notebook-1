<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>UoS ACM Notebook</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<div id="header" style="text-align:right">
  University of Southampton
</div>
<div id="header">
<h1 class="title">UoS ACM Notebook</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#data-structures"><span class="toc-section-number">1</span> Data Structures</a><ul>
<li><a href="#binary-indexed-tree"><span class="toc-section-number">1.1</span> Binary indexed tree</a></li>
<li><a href="#segment-tree"><span class="toc-section-number">1.2</span> Segment tree</a></li>
<li><a href="#treap"><span class="toc-section-number">1.3</span> Treap</a></li>
</ul></li>
<li><a href="#maximum-flows"><span class="toc-section-number">2</span> Maximum Flows</a><ul>
<li><a href="#max-flow"><span class="toc-section-number">2.1</span> Max flow</a></li>
<li><a href="#min-cost-max-flow"><span class="toc-section-number">2.2</span> Min cost max flow</a></li>
</ul></li>
<li><a href="#graphs"><span class="toc-section-number">3</span> Graphs</a><ul>
<li><a href="#bellman-ford"><span class="toc-section-number">3.1</span> Bellman-Ford</a></li>
<li><a href="#euler-cycle"><span class="toc-section-number">3.2</span> Euler cycle</a></li>
<li><a href="#maximum-matching"><span class="toc-section-number">3.3</span> Maximum matching</a></li>
<li><a href="#hamiltonian-path"><span class="toc-section-number">3.4</span> Hamiltonian path</a></li>
<li><a href="#heavy-path-decomposition"><span class="toc-section-number">3.5</span> Heavy path decomposition</a></li>
<li><a href="#lowest-common-ancestor"><span class="toc-section-number">3.6</span> Lowest common ancestor</a></li>
</ul></li>
<li><a href="#mathematics"><span class="toc-section-number">4</span> Mathematics</a><ul>
<li><a href="#number-theoretic-algorithms"><span class="toc-section-number">4.1</span> Number theoretic algorithms</a></li>
<li><a href="#gaussian-elimination"><span class="toc-section-number">4.2</span> Gaussian elimination</a></li>
</ul></li>
<li><a href="#strings"><span class="toc-section-number">5</span> Strings</a><ul>
<li><a href="#knuth-morris-pratt"><span class="toc-section-number">5.1</span> Knuth-Morris-Pratt</a></li>
<li><a href="#rabin-karp"><span class="toc-section-number">5.2</span> Rabin-Karp</a></li>
<li><a href="#longest-palindromic-substring"><span class="toc-section-number">5.3</span> Longest palindromic substring</a></li>
<li><a href="#trie"><span class="toc-section-number">5.4</span> Trie</a></li>
</ul></li>
<li><a href="#geometry"><span class="toc-section-number">6</span> Geometry</a><ul>
<li><a href="#convex-hull"><span class="toc-section-number">6.1</span> Convex hull</a></li>
<li><a href="#miscellaneous-geometry"><span class="toc-section-number">6.2</span> Miscellaneous geometry</a></li>
</ul></li>
<li><a href="#other"><span class="toc-section-number">7</span> Other</a><ul>
<li><a href="#sat"><span class="toc-section-number">7.1</span> 2SAT</a></li>
<li><a href="#kd-tree"><span class="toc-section-number">7.2</span> KD-tree</a></li>
</ul></li>
</ul>
</div>
<h1 id="data-structures"><a href="#TOC"><span class="header-section-number">1</span> Data Structures</a></h1>
<h2 id="binary-indexed-tree"><a href="#TOC"><span class="header-section-number">1.1</span> Binary indexed tree</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> AIB[Nmax],v[Nmax],M,x,y,z;
<span class="dt">int</span> N,num;

<span class="kw">inline</span> <span class="dt">int</span> zeros(<span class="dt">int</span> x) {
  <span class="kw">return</span> ((x ^ (x - <span class="dv">1</span>)) &amp; x );
}
<span class="kw">inline</span> <span class="dt">void</span> Add(<span class="dt">int</span> x, <span class="dt">int</span> q) {
  <span class="kw">for</span> (<span class="dt">int</span> i = x; i &lt;= N; i += zeros(i))
    AIB[i]+=q;
}
<span class="kw">inline</span> <span class="dt">int</span> comp(<span class="dt">int</span> x) {
  <span class="dt">int</span> i, ret = <span class="dv">0</span>;
  <span class="kw">for</span> (i = x; i &gt; <span class="dv">0</span>; i -= zeros(i))
    ret +=AIB[i];
  <span class="kw">return</span> ret;
}</code></pre>
<h2 id="segment-tree"><a href="#TOC"><span class="header-section-number">1.2</span> Segment tree</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">long</span> <span class="dt">long</span> aint[<span class="dv">4</span>*Nmax<span class="dv">+100</span>],v[Nmax],maxim,M,x,z,y,indic;
<span class="dt">long</span> <span class="dt">long</span> up[<span class="dv">4</span>*Nmax<span class="dv">+100</span>];
<span class="dt">long</span> <span class="dt">long</span> ind[<span class="dv">4</span>*Nmax<span class="dv">+100</span>];
<span class="dt">long</span> <span class="dt">long</span> SUM,SUMI;
<span class="dt">long</span> <span class="dt">long</span> N;
<span class="dt">long</span> <span class="dt">long</span> inf = (<span class="dt">long</span> <span class="dt">long</span>)<span class="dv">101010000</span>*<span class="dv">100</span>;

<span class="kw">inline</span> <span class="dt">void</span> relax(<span class="dt">int</span> nod,<span class="dt">int</span> st,<span class="dt">int</span> dr) {
  <span class="dt">long</span> <span class="dt">long</span> mij=(st+dr)/<span class="dv">2</span>;
  <span class="dt">long</span> <span class="dt">long</span> val=up[nod];
  <span class="kw">if</span>(st!=dr) {
    up[<span class="dv">2</span>*nod]+=val;
    up[<span class="dv">2</span>*nod<span class="dv">+1</span>]+=val;
  }
  <span class="kw">if</span>(st==dr)
    ind[nod]=st;
  aint[nod]+=up[nod];
  up[nod]=<span class="dv">0</span>;
}
<span class="dt">void</span> update(<span class="dt">int</span> nod,<span class="dt">int</span> ist,<span class="dt">int</span> idr,<span class="dt">int</span> st,<span class="dt">int</span> dr,<span class="dt">long</span> <span class="dt">long</span> val) {
  <span class="kw">if</span>(ist&lt;=st&amp;&amp;idr&gt;=dr) {
    aint[nod]+=val;
    <span class="kw">if</span>(st!=dr) {
      up[<span class="dv">2</span>*nod]+=val;
      up[<span class="dv">2</span>*nod<span class="dv">+1</span>]+=val;
    }
    <span class="kw">else</span> ind[nod]=ist;
  } <span class="kw">else</span> {
    <span class="kw">if</span>(aint[nod]&gt;<span class="dv">0</span>)
      relax(nod,st,dr);
    <span class="dt">long</span> <span class="dt">long</span> mij=(st+dr)/<span class="dv">2</span>;

    <span class="kw">if</span>(ist&lt;=mij)
      update(<span class="dv">2</span>*nod,ist,idr,st,mij,val);
    <span class="kw">if</span>(idr&gt;mij)
      update(<span class="dv">2</span>*nod<span class="dv">+1</span>,ist,idr,mij<span class="dv">+1</span>,dr,val);
    <span class="kw">if</span>(up[nod*<span class="dv">2</span>])
      relax(nod*<span class="dv">2</span>,st,mij);
    <span class="kw">if</span>(up[nod*<span class="dv">2+1</span>])
      relax(nod*<span class="dv">2+1</span>,mij<span class="dv">+1</span>,dr);
    <span class="kw">if</span>(aint[nod*<span class="dv">2</span>]&gt;aint[nod*<span class="dv">2+1</span>]) {
      aint[nod]=aint[<span class="dv">2</span>*nod<span class="dv">+1</span>];
      ind[nod]=ind[<span class="dv">2</span>*nod<span class="dv">+1</span>];
    } <span class="kw">else</span> {
      aint[nod]=aint[<span class="dv">2</span>*nod];
      ind[nod]=ind[<span class="dv">2</span>*nod];
    }
  }
}</code></pre>
<h2 id="treap"><a href="#TOC"><span class="header-section-number">1.3</span> Treap</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> T {
  <span class="dt">int</span> key, priority,nr;
  T *left, *right;
  T() {}
  T(<span class="dt">int</span> key, <span class="dt">int</span> priority, T* left, T* right) {
    <span class="kw">this</span>-&gt;key = key;
    <span class="kw">this</span>-&gt;priority = priority;
    <span class="kw">this</span>-&gt;left = left, <span class="kw">this</span>-&gt;right = right;
    <span class="kw">this</span>-&gt;nr = <span class="dv">0</span>;
  }
} *R, *nil; <span class="co">// nil indica un nod &#39;gol&#39;</span>

<span class="dt">void</span> init(T* &amp;R) {
  srand(<span class="dt">unsigned</span>(time(<span class="dv">0</span>)));
  R = nil = <span class="kw">new</span> T(<span class="dv">0</span>, <span class="dv">0</span>, NULL, NULL);
}
<span class="dt">void</span> parc(T* n){
  <span class="kw">if</span>(n== nil)
    <span class="kw">return</span>;
  parc(n-&gt;left);
  parc(n-&gt;right);
}
<span class="kw">inline</span> <span class="dt">void</span> update(T* &amp;n){
  <span class="kw">if</span>(n==nil)
    <span class="kw">return</span>;
  n-&gt;nr = n-&gt;left-&gt;nr + n-&gt;right-&gt;nr + <span class="dv">1</span>;

}
<span class="dt">int</span> search(T* n, <span class="dt">int</span> key) {
  <span class="kw">if</span> (n == nil) <span class="kw">return</span> <span class="dv">0</span>;
  <span class="kw">if</span> (key == n-&gt;key) <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">if</span> (key &lt; n-&gt;key)
    <span class="kw">return</span> search(n-&gt;left, key);
  <span class="kw">else</span>
    <span class="kw">return</span> search(n-&gt;right, key);
  update(n-&gt;right);
  update(n-&gt;left);
  update(n);
}
<span class="dt">void</span> rotleft(T* &amp;n) {
  T *t = n-&gt;left;
  n-&gt;left = t-&gt;right, t-&gt;right = n;
  n = t;
  update(t-&gt;right);
  update(t-&gt;left);
  update(t);
  update(n-&gt;right);
  update(n);
}
<span class="dt">void</span> rotright(T* &amp;n) {
  T *t = n-&gt;right;
  n-&gt;right = t-&gt;left, t-&gt;left = n;
  n = t;
  update(t-&gt;right);
  update(t-&gt;left);
  update(t);
  update(n-&gt;left);
  update(n);
}
<span class="dt">int</span> nth(T* &amp;n,<span class="dt">int</span> nr){
  <span class="kw">if</span>(n==nil)
    <span class="kw">return</span> -<span class="dv">1</span>;
  <span class="kw">if</span>(nr==<span class="dv">0</span>)
    <span class="kw">return</span> n-&gt;key;
  <span class="dt">int</span> leftval = n-&gt;left-&gt;nr;
  <span class="kw">if</span>(nr-leftval == <span class="dv">1</span>)
    <span class="kw">return</span> n-&gt;key;
  <span class="kw">if</span>(leftval &gt;= nr)
    <span class="kw">return</span> nth(n-&gt;left,nr);
  <span class="kw">return</span> nth(n-&gt;right,nr-leftval<span class="dv">-1</span>);
}
<span class="dt">void</span> balance(T* &amp;n) {
  <span class="kw">if</span> (n-&gt;left-&gt;priority &gt; n-&gt;priority)
    rotleft(n);
  <span class="kw">else</span> <span class="kw">if</span> (n-&gt;right-&gt;priority &gt; n-&gt;priority)
    rotright(n);
  update(n-&gt;right);
  update(n-&gt;left);
  update(n);
}
<span class="dt">void</span> insert(T* &amp;n, <span class="dt">int</span> key, <span class="dt">int</span> priority) {
  <span class="kw">if</span> (n == nil) {
    n = <span class="kw">new</span> T(key, priority, nil, nil);
    n-&gt;nr=<span class="dv">1</span>;
    <span class="kw">return</span>;
  }
  (n-&gt;nr)++;
  <span class="kw">if</span> (key &lt;= n-&gt;key)
    insert(n-&gt;left, key, priority);
  <span class="kw">else</span> <span class="kw">if</span> (key &gt; n-&gt;key)
    insert(n-&gt;right, key, priority);
  balance(n);
}</code></pre>
<h1 id="maximum-flows"><a href="#TOC"><span class="header-section-number">2</span> Maximum Flows</a></h1>
<h2 id="max-flow"><a href="#TOC"><span class="header-section-number">2.1</span> Max flow</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> flux[<span class="dv">1010</span>][<span class="dv">1010</span>];
<span class="dt">int</span> c[<span class="dv">1010</span>][<span class="dv">1010</span>];
<span class="dt">int</span> tata[<span class="dv">1010</span>];
<span class="dt">int</span> viz[<span class="dv">1010</span>],flow;
<span class="dt">int</span> coad[<span class="dv">1015</span>];
<span class="dt">int</span> Q,x,y,z,N,act,M,flow_min;

vector&lt;<span class="dt">int</span>&gt; g[<span class="dv">1010</span>];

<span class="dt">int</span> BF() {
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=N;++i) {
    viz[i]=<span class="dv">0</span>;
  }
  coad[<span class="dv">0</span>]=<span class="dv">1</span>;
  <span class="dt">int</span> st=<span class="dv">0</span>,dr=<span class="dv">1</span>;
  viz[<span class="dv">1</span>]=<span class="dv">1</span>;
  <span class="kw">while</span>(st&lt;dr) {
    act=coad[st];
    <span class="kw">if</span>(act!=N)
      <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;g[act].size();++i) {
        Q = g[act][i];
        <span class="kw">if</span>(c[act][Q] == flux[act][Q] || viz[Q])
          <span class="kw">continue</span>;
        viz[Q]=<span class="dv">1</span>;
        coad[dr++]=Q;
        tata[Q]=act;
      }
    ++st;
  }
  <span class="kw">return</span> viz[N];
}
<span class="dt">int</span> main() {
  <span class="kw">for</span>(flow=<span class="dv">0</span>; BF();) {
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;g[N].size();++i) {
      act=g[N][i];
      <span class="kw">if</span>(flux[act][N]==c[act][N] ||!viz[act])
        <span class="kw">continue</span>;
      tata[N]=act;

      flow_min=<span class="dv">10101000</span>;
      <span class="kw">for</span>(<span class="dt">int</span> nod=N;nod!=<span class="dv">1</span>;nod=tata[nod])
        flow_min=min(flow_min,c[tata[nod]][nod]-flux[tata[nod]][nod]);
      <span class="kw">if</span>(flow_min==<span class="dv">0</span>)
        <span class="kw">continue</span>;
      <span class="kw">for</span>(<span class="dt">int</span> nod=N;nod!=<span class="dv">1</span>;nod=tata[nod]) {
        flux[tata[nod]][nod]+=flow_min;
        flux[nod][tata[nod]]-=flow_min;
      }
      flow+=flow_min;
    }
  }
}</code></pre>
<h2 id="min-cost-max-flow"><a href="#TOC"><span class="header-section-number">2.2</span> Min cost max flow</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> N, M, S, D;
vector&lt;<span class="dt">int</span>&gt; G[MAXN];

<span class="dt">int</span> cap[MAXN][MAXN];
<span class="dt">int</span> cost[MAXN][MAXN];
<span class="dt">int</span> flow[MAXN][MAXN];

<span class="dt">int</span> d[MAXN];
<span class="dt">int</span> prev[MAXN];
<span class="dt">bool</span> found;

<span class="dt">int</span> bellman_ford() {
  vector&lt;<span class="dt">bool</span>&gt; inqueue(N + <span class="dv">1</span>, <span class="kw">false</span>);
  queue&lt;<span class="dt">int</span>&gt; q;
  q.push(S);
  inqueue[S] = <span class="kw">true</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i) {
    prev[i] = -<span class="dv">1</span>;
    d[i] = INF;
  }
  d[S] = <span class="dv">0</span>;

  <span class="kw">while</span> (!q.empty()) {
    <span class="dt">int</span> node = q.front();
    q.pop();
    inqueue[node] = <span class="kw">false</span>;
    vector&lt;<span class="dt">int</span>&gt;::iterator it;
    <span class="kw">for</span> (it = G[node].begin(); it != G[node].end(); ++it) {
      <span class="kw">if</span> (cap[node][*it] - flow[node][*it] &lt;= <span class="dv">0</span>)
        <span class="kw">continue</span>;
      <span class="kw">if</span> (cost[node][*it] + d[node] &lt; d[*it]) {
        prev[*it] = node;
        d[*it] = cost[node][*it] + d[node];
        <span class="kw">if</span> (!inqueue[*it]) {
          q.push(*it);
          inqueue[*it] = <span class="kw">true</span>;
        }
      }
    }
  }

  <span class="kw">if</span> (d[D] &lt; INF / <span class="dv">2</span>) {
    found = <span class="kw">true</span>;
    <span class="dt">int</span> fmin = INF;
    <span class="kw">for</span> (<span class="dt">int</span> node = D; node != S; node = prev[node])
      fmin = min(fmin, cap[prev[node]][node] - flow[prev[node]][node]);
    <span class="kw">for</span> (<span class="dt">int</span> node = D; node != S; node = prev[node]) {
      flow[prev[node]][node] += fmin;
      flow[node][prev[node]] -= fmin;
    }
    <span class="kw">return</span> d[D] * fmin;
  }
  <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="dt">long</span> <span class="dt">long</span> mfmc() {
  <span class="dt">long</span> <span class="dt">long</span> result = <span class="dv">0</span>;
  found = <span class="kw">true</span>;
  <span class="kw">while</span> (found) {
    found = <span class="kw">false</span>;
    result += bellman_ford();
  }
  <span class="kw">return</span> result;
}</code></pre>
<h1 id="graphs"><a href="#TOC"><span class="header-section-number">3</span> Graphs</a></h1>
<h2 id="bellman-ford"><a href="#TOC"><span class="header-section-number">3.1</span> Bellman-Ford</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> bellmanford() {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i)
      dist[i] = INF;
  dist[<span class="dv">1</span>] = <span class="dv">0</span>;

  queue&lt;<span class="dt">int</span>&gt; q;
  q.push(<span class="dv">1</span>);
  inqueue[<span class="dv">1</span>] = <span class="kw">true</span>;
  cnt[<span class="dv">1</span>] = <span class="dv">1</span>;
  <span class="kw">while</span> (!q.empty()) {
    <span class="dt">int</span> node = q.front();
    q.pop();
    inqueue[node] = <span class="kw">false</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[node].size(); ++i) {
      <span class="dt">int</span> next = G[node][i];
      <span class="kw">if</span> (dist[node] + C[node][i] &lt; dist[next]) {
        dist[next] = dist[node] + C[node][i];
        <span class="kw">if</span> (!inqueue[next]) {
          <span class="kw">if</span> (cnt[next] &gt; n)
            <span class="kw">return</span> -<span class="dv">1</span>;
          q.push(next);
          inqueue[next] = <span class="kw">true</span>;
          cnt[next]++;
        }
      }
    }
  }
  <span class="kw">return</span> <span class="dv">1</span>;
}</code></pre>
<h2 id="euler-cycle"><a href="#TOC"><span class="header-section-number">3.2</span> Euler cycle</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp">list&lt;<span class="dt">int</span>&gt; G[MAXN];
vector&lt;<span class="dt">int</span>&gt; sol;
<span class="dt">int</span> deg[MAXN];
<span class="dt">bool</span> vis[MAXN];
<span class="dt">void</span> dfs(<span class="dt">int</span> node) {
  vis[node] = <span class="kw">true</span>;
  list&lt;<span class="dt">int</span>&gt;::iterator it;
  <span class="kw">for</span> (it = G[node].begin(); it != G[node].end(); ++it) {
    <span class="kw">if</span> (vis[*it])
      <span class="kw">continue</span>;
    dfs(*it);
  }
}
<span class="dt">void</span> rem_edge(<span class="dt">int</span> v, <span class="dt">int</span> w) {
  G[v].pop_front();
  list&lt;<span class="dt">int</span>&gt;::iterator it;
  <span class="kw">for</span> (it = G[w].begin(); it != G[w].end(); ++it)
    <span class="kw">if</span> (*it == v) {
      G[w].erase(it);
      <span class="kw">break</span>;
    }
}

stack&lt;<span class="dt">int</span>&gt; st;
<span class="dt">void</span> euler(<span class="dt">int</span> v) {
  <span class="kw">while</span> (!G[v].empty()) {
    <span class="dt">int</span> w = *G[v].begin();
    rem_edge(v, w);
    st.push(v);
    v = w;
  }
}
<span class="dt">int</span> main() {
  st.push(<span class="dv">1</span>);
  <span class="kw">while</span> (!st.empty()) {
    <span class="dt">int</span> v = st.top();
    st.pop();
    euler(v);
    sol.push_back(v);
  }
  reverse(sol.begin(), sol.end());
}</code></pre>
<h2 id="maximum-matching"><a href="#TOC"><span class="header-section-number">3.3</span> Maximum matching</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> N,M,K;
<span class="dt">int</span> v[<span class="dv">25000</span>],x,p=<span class="dv">0</span>;
<span class="dt">char</span> car;
vector &lt;<span class="dt">int</span>&gt; g[<span class="dv">25000</span>];
<span class="dt">int</span> l[<span class="dv">25000</span>],r[<span class="dv">25000</span>],u[<span class="dv">25000</span>],was[<span class="dv">25000</span>],S;
<span class="dt">int</span> cupj(<span class="dt">int</span> q) {
  <span class="kw">if</span>(was[q])
    <span class="kw">return</span> <span class="dv">0</span>;
  was[q]=<span class="dv">1</span>;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;g[q].size();++i) {
    <span class="kw">if</span>(!r[g[q][i]]) {
      l[q]=g[q][i];
      r[g[q][i]]=q;
      <span class="kw">return</span> <span class="dv">1</span>;
    }
  }
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;g[q].size();++i) {
    <span class="kw">if</span>(cupj(r[g[q][i]])) {
      l[q]=g[q][i];
      r[g[q][i]]=q;
      <span class="kw">return</span> <span class="dv">1</span>;
    }
  }
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="hamiltonian-path"><a href="#TOC"><span class="header-section-number">3.4</span> Hamiltonian path</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> inf = <span class="dv">1000000000</span>;
<span class="dt">int</span> N,M,x,y,z,Sol,b[<span class="dv">262150</span>][<span class="dv">22</span>],c[<span class="dv">22</span>][<span class="dv">22</span>];
vector&lt;<span class="dt">int</span>&gt; a[<span class="dv">22</span>];

<span class="dt">int</span> best(<span class="dt">int</span> conf, <span class="dt">int</span> last) {
  <span class="kw">if</span>(b[conf][last]&gt;=<span class="dv">0</span>)
    <span class="kw">return</span> b[conf][last];
  b[conf][last]=inf;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;a[last].size();++i)
    <span class="kw">if</span>(conf &amp; (<span class="dv">1</span>&lt;&lt;a[last][i])) {
      <span class="kw">if</span>(a[last][i]==<span class="dv">0</span> &amp;&amp; conf!=(<span class="dv">1</span>&lt;&lt;last)+<span class="dv">1</span>)
        <span class="kw">continue</span>;
      <span class="kw">if</span>(b[conf][last] &gt; best(conf^(<span class="dv">1</span>&lt;&lt;last),a[last][i])+c[a[last][i]][last])
        b[conf][last] = best(conf^(<span class="dv">1</span>&lt;&lt;last),a[last][i])+c[a[last][i]][last];
    }
  <span class="kw">return</span> b[conf][last];
}</code></pre>
<h2 id="heavy-path-decomposition"><a href="#TOC"><span class="header-section-number">3.5</span> Heavy path decomposition</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> N, M, nL;
<span class="dt">int</span> v[MAXN], fol[MAXN], niv[MAXN], w[MAXN], l[MAXN];
<span class="dt">int</span> aint[<span class="dv">4</span>*MAXN];
<span class="dt">int</span> lTata[MAXN], lNiv[MAXN], lDim[MAXN], lPoz[MAXN];
vector&lt;<span class="dt">int</span>&gt; G[MAXN], P[MAXN];
pair&lt;<span class="dt">int</span>, pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &gt; op[MAXN];

<span class="dt">void</span> df(<span class="dt">int</span> nod) {
  fol[nod] = <span class="dv">1</span>;
  w[nod] = <span class="dv">1</span>;
  <span class="dt">int</span> hN = -<span class="dv">1</span>, frunza = <span class="dv">1</span>;

  <span class="kw">for</span>(vector&lt;<span class="dt">int</span>&gt; :: iterator it = G[nod].begin(); it != G[nod].end(); ++it) {
    <span class="kw">if</span>(fol[*it])
      <span class="kw">continue</span>;
    frunza = <span class="dv">0</span>;
    niv[*it] = niv[nod] + <span class="dv">1</span>;
    df(*it);
    w[nod] += w[*it];
    <span class="kw">if</span>(hN == -<span class="dv">1</span>)
      hN = *it;
    <span class="kw">else</span> <span class="kw">if</span>(w[hN] &lt; w[*it])
      hN = *it;
  }
  <span class="kw">if</span>(frunza) {
    l[nod] = ++nL;
    lDim[nL]=<span class="dv">1</span>;
    P[nL].push_back(nod);
    <span class="kw">return</span>;
  }
  l[nod] = l[hN];
  ++lDim[l[nod]];
  P[l[nod]].push_back(nod);

  <span class="kw">for</span>(vector&lt;<span class="dt">int</span>&gt; :: iterator it = G[nod].begin(); it != G[nod].end(); ++it) {
    <span class="kw">if</span>((*it) == hN || niv[*it] &lt; niv[nod])
      <span class="kw">continue</span>;

    lTata[l[*it]] = nod;
    lNiv[l[*it]] = niv[nod];
  }
}
<span class="dt">void</span> build(<span class="dt">int</span> nod, <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> decalaj, <span class="dt">int</span> lant) {
  <span class="kw">if</span>(left == right) {
    aint[nod + decalaj] = v[ P[lant][left - <span class="dv">1</span>] ];
    <span class="kw">return</span>;
  }
  <span class="dt">int</span> med = (left + right) / <span class="dv">2</span>;
  build(nod * <span class="dv">2</span>, left, med, decalaj, lant);
  build(nod * <span class="dv">2</span> + <span class="dv">1</span>, med<span class="dv">+1</span>, right, decalaj, lant);
  aint[nod + decalaj] = max(aint[nod * <span class="dv">2</span> + decalaj], aint[nod * <span class="dv">2</span> + <span class="dv">1</span> + decalaj]);
}
<span class="dt">void</span> make_paths() {
  niv[<span class="dv">1</span>] = <span class="dv">1</span>;
  df(<span class="dv">1</span>);
  <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= nL; ++i) {
    reverse(P[i].begin(), P[i].end());
    <span class="kw">if</span>(i &gt; <span class="dv">1</span>)
      lPoz[i] = lPoz[i<span class="dv">-1</span>] + lDim[i<span class="dv">-1</span>] * <span class="dv">4</span>;
    build(<span class="dv">1</span>, <span class="dv">1</span>, lDim[i], lPoz[i], i);
  }
}
<span class="dt">void</span> update(<span class="dt">int</span> nod, <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> poz, <span class="dt">int</span> val, <span class="dt">int</span> decalaj) {
  <span class="kw">if</span>(left == right) {
    aint[nod + decalaj] = val;
    <span class="kw">return</span>;
  }
  <span class="dt">int</span> med = (left + right) / <span class="dv">2</span>;
  <span class="kw">if</span>(poz&lt;=med)
    update(nod * <span class="dv">2</span>, left, med, poz, val, decalaj);
  <span class="kw">else</span>
    update(nod * <span class="dv">2</span> + <span class="dv">1</span>, med<span class="dv">+1</span>, right, poz, val, decalaj);
  aint[nod + decalaj] = max(aint[nod * <span class="dv">2</span> + decalaj], aint[nod * <span class="dv">2</span> + <span class="dv">1</span> + decalaj]);
}
<span class="dt">int</span> query(<span class="dt">int</span> nod, <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> qleft, <span class="dt">int</span> qright, <span class="dt">int</span> decalaj) {
  <span class="kw">if</span>(qleft &lt;= left &amp;&amp; right &lt;= qright)
    <span class="kw">return</span> aint[nod + decalaj];
  <span class="dt">int</span> med = (left + right) / <span class="dv">2</span>, rez = <span class="dv">0</span>;
  <span class="kw">if</span>(qleft &lt;= med)
    rez = max(rez, query(nod * <span class="dv">2</span>, left, med, qleft, qright, decalaj) );
  <span class="kw">if</span>(med &lt; qright)
    rez = max(rez, query(nod * <span class="dv">2</span> + <span class="dv">1</span>, med + <span class="dv">1</span>, right, qleft, qright, decalaj) );
  <span class="kw">return</span> rez;
}
<span class="dt">void</span> solve() {
  <span class="dt">int</span> t, x, y, sol = <span class="dv">0</span>;
  <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= M; ++i) {
    t = op[i].first; x = op[i].second.first, y = op[i].second.second;
    <span class="kw">if</span>(t==<span class="dv">0</span>) {
      update(<span class="dv">1</span>, <span class="dv">1</span>, lDim[l[x]], niv[x] - lNiv[l[x]], y, lPoz[l[x]]);
    } <span class="kw">else</span> {
      sol = <span class="dv">0</span>;
      <span class="kw">while</span>(<span class="dv">1</span>) {
        <span class="kw">if</span>(l[x] == l[y]) {
          <span class="kw">if</span>(niv[x] &gt; niv[y])
            swap(x, y);
          sol = max(sol, query(<span class="dv">1</span>, <span class="dv">1</span>, lDim[l[x]], niv[x] - lNiv[l[x]], niv[y] - lNiv[l[x]], lPoz[l[x]]));
          <span class="kw">break</span>;
        }
        <span class="kw">if</span>(lNiv[l[x]] &lt; lNiv[l[y]])
          swap(x, y);
        sol = max(sol, query(<span class="dv">1</span>, <span class="dv">1</span>, lDim[l[x]], <span class="dv">1</span>, niv[x] - lNiv[l[x]], lPoz[l[x]]));
        x = lTata[l[x]];
      }
    }
  }
}</code></pre>
<h2 id="lowest-common-ancestor"><a href="#TOC"><span class="header-section-number">3.6</span> Lowest common ancestor</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> K, N, M, x, y, L[<span class="dv">200010</span>], H[<span class="dv">200010</span>], Lg[<span class="dv">200010</span>], First[<span class="dv">100010</span>], Rmq[<span class="dv">20</span>][<span class="dv">400010</span>];
vector&lt;<span class="dt">int</span>&gt; G[<span class="dv">100010</span>];

<span class="dt">void</span> dfs(<span class="dt">int</span> nod, <span class="dt">int</span> lev) {
  H[++K] = nod;
  L[K] = lev;
  First[nod] = K;
  <span class="dt">int</span> z = G[nod].size();
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;z;++i) {
    dfs(G[nod][i],lev<span class="dv">+1</span>);
    H[++K] = nod;
    L[K] = lev;
  }
}
<span class="dt">void</span> rmq() {
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;=K;++i)
    Lg[i] = Lg[i/<span class="dv">2</span>]+<span class="dv">1</span>;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=K;++i)
    Rmq[<span class="dv">0</span>][i]=i;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;(<span class="dv">1</span>&lt;&lt;i) &lt; K; ++i)
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=K-(<span class="dv">1</span>&lt;&lt;i);++j) {
      <span class="dt">int</span> l = <span class="dv">1</span>&lt;&lt; (i<span class="dv">-1</span>);
      Rmq[i][j] = Rmq[i<span class="dv">-1</span>][j];
      <span class="kw">if</span>(L[Rmq[i<span class="dv">-1</span>][j + l]] &lt; L[Rmq[i][j]])
        Rmq[i][j] = Rmq[i<span class="dv">-1</span>][j + l];
    }
}
<span class="dt">int</span> lca(<span class="dt">int</span> x, <span class="dt">int</span> y) {
  <span class="dt">int</span> a = First[x], b = First[y];
  <span class="kw">if</span>(a&gt;b) {
    <span class="dt">int</span> c=a;
    a=b;
    b=c;
  }
  <span class="dt">int</span> diff = b - a + <span class="dv">1</span>;
  <span class="dt">int</span> l = Lg[diff];
  <span class="dt">int</span> sol = Rmq[l][a];
  <span class="dt">int</span> sh = diff - (<span class="dv">1</span> &lt;&lt; l);
  <span class="kw">if</span>(L[sol] &gt; L[Rmq[l][a + sh]])
    sol = Rmq[l][a + sh];
  <span class="kw">return</span> H[sol];
}</code></pre>
<h1 id="mathematics"><a href="#TOC"><span class="header-section-number">4</span> Mathematics</a></h1>
<h2 id="number-theoretic-algorithms"><a href="#TOC"><span class="header-section-number">4.1</span> Number theoretic algorithms</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> vector&lt;<span class="dt">int</span>&gt; VI;
<span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; PII;

<span class="dt">int</span> mod(<span class="dt">int</span> a, <span class="dt">int</span> b) {
  <span class="kw">return</span> ((a%b)+b)%b;
}
<span class="dt">int</span> gcd(<span class="dt">int</span> a, <span class="dt">int</span> b) {
  <span class="dt">int</span> tmp;
  <span class="kw">while</span>(b){a%=b; tmp=a; a=b; b=tmp;}
  <span class="kw">return</span> a;
}
<span class="dt">int</span> lcm(<span class="dt">int</span> a, <span class="dt">int</span> b) {
  <span class="kw">return</span> a/gcd(a,b)*b;
}
<span class="dt">int</span> extended_euclid(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> &amp;x, <span class="dt">int</span> &amp;y) {
  <span class="dt">int</span> xx = y = <span class="dv">0</span>;
  <span class="dt">int</span> yy = x = <span class="dv">1</span>;
  <span class="kw">while</span> (b) {
    <span class="dt">int</span> q = a/b;
    <span class="dt">int</span> t = b; b = a%b; a = t;
    t = xx; xx = x-q*xx; x = t;
    t = yy; yy = y-q*yy; y = t;
  }
  <span class="kw">return</span> a;
}
VI modular_linear_equation_solver(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> n) {
  <span class="dt">int</span> x, y;
  VI solutions;
  <span class="dt">int</span> d = extended_euclid(a, n, x, y);
  <span class="kw">if</span> (!(b%d)) {
    x = mod (x*(b/d), n);
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; d; i++)
      solutions.push_back(mod(x + i*(n/d), n));
  }
  <span class="kw">return</span> solutions;
}
<span class="dt">int</span> mod_inverse(<span class="dt">int</span> a, <span class="dt">int</span> n) {
  <span class="dt">int</span> x, y;
  <span class="dt">int</span> d = extended_euclid(a, n, x, y);
  <span class="kw">if</span> (d &gt; <span class="dv">1</span>) <span class="kw">return</span> -<span class="dv">1</span>;
  <span class="kw">return</span> mod(x,n);
}
PII chinese_remainder_theorem(<span class="dt">int</span> x, <span class="dt">int</span> a, <span class="dt">int</span> y, <span class="dt">int</span> b) {
  <span class="dt">int</span> s, t;
  <span class="dt">int</span> d = extended_euclid(x, y, s, t);
  <span class="kw">if</span> (a%d != b%d) <span class="kw">return</span> make_pair(<span class="dv">0</span>, -<span class="dv">1</span>);
  <span class="kw">return</span> make_pair(mod(s*b*x+t*a*y,x*y)/d, x*y/d);
}
PII chinese_remainder_theorem(<span class="dt">const</span> VI &amp;x, <span class="dt">const</span> VI &amp;a) {
  PII ret = make_pair(a[<span class="dv">0</span>], x[<span class="dv">0</span>]);
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; x.size(); i++) {
    ret = chinese_remainder_theorem(ret.second, ret.first, x[i], a[i]);
    <span class="kw">if</span> (ret.second == -<span class="dv">1</span>) <span class="kw">break</span>;
  }
  <span class="kw">return</span> ret;
}
<span class="dt">void</span> linear_diophantine(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c, <span class="dt">int</span> &amp;x, <span class="dt">int</span> &amp;y) {
  <span class="dt">int</span> d = gcd(a,b);
  <span class="kw">if</span> (c%d) {
    x = y = -<span class="dv">1</span>;
  } <span class="kw">else</span> {
    x = c/d * mod_inverse(a/d, b/d);
    y = (c-a*x)/b;
  }
}</code></pre>
<h2 id="gaussian-elimination"><a href="#TOC"><span class="header-section-number">4.2</span> Gaussian elimination</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i,j,k;
<span class="dt">int</span> N,M;
<span class="dt">double</span> A[<span class="dv">303</span>][<span class="dv">303</span>];
<span class="dt">double</span> X[<span class="dv">303</span>];

<span class="dt">int</span> main() {
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=N;++i) {
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=M<span class="dv">+1</span>;++j) {
      scanf(<span class="st">&quot;%lf&quot;</span>,&amp;A[i][j]);
    }
  }
  i=<span class="dv">1</span>,j=<span class="dv">1</span>;
  <span class="kw">while</span>(i&lt;=N &amp;&amp; j&lt;=M) {
    <span class="kw">for</span>(k=i;k&lt;=N;++k)
      <span class="kw">if</span>(A[k][j]&lt;-EPS||A[k][j]&gt;EPS)
        <span class="kw">break</span>;
    <span class="kw">if</span>(k==N<span class="dv">+1</span>) {
      ++j;
      <span class="kw">continue</span>;
    }
    <span class="kw">if</span>(k!=i) {
      <span class="kw">for</span>(<span class="dt">int</span> q=<span class="dv">1</span>;q&lt;=M<span class="dv">+1</span>;++q) {
        <span class="dt">double</span> aux = A[i][q];
        A[i][q]= A[k][q];
        A[k][q]= aux;
      }
    }
    <span class="kw">for</span>(<span class="dt">int</span> q=j<span class="dv">+1</span>;q&lt;=M<span class="dv">+1</span>;++q) {
      A[i][q]=A[i][q]/A[i][j];
    }
    A[i][j]=<span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> u=i<span class="dv">+1</span>;u&lt;=N;++u) {
      <span class="kw">for</span>(<span class="dt">int</span> q=j<span class="dv">+1</span>;q&lt;=M<span class="dv">+1</span>;++q) {
        A[u][q]-=A[u][j]*A[i][q];
      }
      A[u][j]=<span class="dv">0</span>;
    }
    ++i;++j;
  }
}</code></pre>
<h1 id="strings"><a href="#TOC"><span class="header-section-number">5</span> Strings</a></h1>
<h2 id="knuth-morris-pratt"><a href="#TOC"><span class="header-section-number">5.1</span> Knuth-Morris-Pratt</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; prefix(<span class="dt">const</span> string&amp; str) {
  vector&lt;<span class="dt">int</span>&gt; pi(str.size(), <span class="dv">0</span>);
  <span class="dt">int</span> k = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; str.size(); ++i) {
    <span class="kw">while</span> (k &gt; <span class="dv">0</span> &amp;&amp; str[i] != str[k])
      k = pi[k - <span class="dv">1</span>];
    <span class="kw">if</span> (str[i] == str[k])
      ++k;
    pi[i] = k;
  }
  <span class="kw">return</span> pi;
}
vector&lt;<span class="dt">int</span>&gt; match(<span class="dt">const</span> string&amp; str, <span class="dt">const</span> string&amp; patt) {
  vector&lt;<span class="dt">int</span>&gt; matches;
  vector&lt;<span class="dt">int</span>&gt; pi = prefix(patt);
  <span class="dt">int</span> k = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; str.size(); ++i) {
    <span class="kw">while</span> (k &gt; <span class="dv">0</span> &amp;&amp; str[i] != patt[k])
      k = pi[k - <span class="dv">1</span>];
    <span class="kw">if</span> (str[i] == patt[k])
      ++k;
    <span class="kw">if</span> (k == patt.size())
      matches.push_back(i - patt.size() + <span class="dv">1</span>);
  }
  <span class="kw">return</span> matches;
}</code></pre>
<h2 id="rabin-karp"><a href="#TOC"><span class="header-section-number">5.2</span> Rabin-Karp</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> A[MAXN], B[MAXN];
<span class="dt">int</span> NA, NB;
<span class="dt">int</span> hashA1, hashA2, P1, P2;
<span class="dt">char</span> match[MAXN];

<span class="dt">int</span> main() {
  P1 = P2 = <span class="dv">1</span>;
  hashA1 = hashA2 = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NA; i++) {
    hashA1 = (hashA1 * P + A[i]) % MOD1;
    hashA2 = (hashA2 * P + A[i]) % MOD2;
    <span class="kw">if</span> (i != <span class="dv">0</span>)
      P1 = (P1 * P) % MOD1,
         P2 = (P2 * P) % MOD2;
  }
  <span class="dt">int</span> hash1 = <span class="dv">0</span>, hash2 = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NA; i++)
    hash1 = (hash1 * P + B[i]) % MOD1,
          hash2 = (hash2 * P + B[i]) % MOD2;
  <span class="dt">int</span> Nr = <span class="dv">0</span>;
  <span class="kw">if</span> (hash1 == hashA1 &amp;&amp; hash2 == hashA2)
    match[<span class="dv">0</span>] = <span class="dv">1</span>, Nr++;
  <span class="kw">for</span> (<span class="dt">int</span> i = NA; i &lt; NB; i++) {
    hash1 = ((hash1 - (B[i - NA] * P1) % MOD1 + MOD1) * P + B[i]) % MOD1;
    hash2 = ((hash2 - (B[i - NA] * P2) % MOD2 + MOD2) * P + B[i]) % MOD2;
    <span class="kw">if</span> (hash1 == hashA1 &amp;&amp; hash2 == hashA2)
      match[ i - NA + <span class="dv">1</span> ] = <span class="dv">1</span>, Nr++;
  }
}</code></pre>
<h2 id="longest-palindromic-substring"><a href="#TOC"><span class="header-section-number">5.3</span> Longest palindromic substring</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> N;
<span class="dt">char</span> s[MAXN];
<span class="dt">int</span> dp[<span class="dv">2</span>][MAXN];
<span class="dt">long</span> <span class="dt">long</span> res = <span class="dv">0</span>;

<span class="dt">int</span> explode(<span class="dt">int</span> l, <span class="dt">int</span> r) {
  <span class="dt">int</span> len = <span class="dv">0</span>;
  <span class="kw">for</span> (; l &gt;= <span class="dv">0</span> &amp;&amp; r &lt; N &amp;&amp; s[l] == s[r]; --l, ++r, ++len);
  <span class="kw">return</span> len;
}
<span class="dt">void</span> odd_center() {
  <span class="dt">int</span> last = -<span class="dv">1</span>, right = -<span class="dv">1</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i) {
    <span class="kw">if</span> (right &gt;= i)
      dp[<span class="dv">0</span>][i] = min(dp[<span class="dv">0</span>][<span class="dv">2</span> * last - i], right - i);

    <span class="dt">int</span> l = i - dp[<span class="dv">0</span>][i];
    <span class="dt">int</span> r = i + dp[<span class="dv">0</span>][i];
    dp[<span class="dv">0</span>][i] += explode(l, r);
    <span class="kw">if</span> (i + dp[<span class="dv">0</span>][i] &gt; right) {
      last = i;
      right = i + dp[<span class="dv">0</span>][i];
    }
    res += (<span class="dt">long</span> <span class="dt">long</span>) dp[<span class="dv">0</span>][i];
  }
}
<span class="dt">void</span> even_center() {
  <span class="dt">int</span> last = -<span class="dv">1</span>, right = -<span class="dv">1</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i) {
    <span class="kw">if</span> (s[i] != s[i + <span class="dv">1</span>])
      <span class="kw">continue</span>;
    <span class="kw">if</span> (right &gt; i)
      dp[<span class="dv">1</span>][i] = min(dp[<span class="dv">1</span>][<span class="dv">2</span> * last - i], right - i - <span class="dv">1</span>);
    <span class="dt">int</span> l = i - dp[<span class="dv">1</span>][i];
    <span class="dt">int</span> r = i + dp[<span class="dv">1</span>][i] + <span class="dv">1</span>;
    dp[<span class="dv">1</span>][i] += explode(l, r);
    <span class="kw">if</span> (i + dp[<span class="dv">1</span>][i] + <span class="dv">1</span> &gt; right) {
      last = i;
      right = i + dp[<span class="dv">1</span>][i] + <span class="dv">1</span>;
    }
    res += (<span class="dt">long</span> <span class="dt">long</span>) dp[<span class="dv">1</span>][i];
  }
}
<span class="dt">int</span> main() {
  odd_center();
  even_center();
}</code></pre>
<h2 id="trie"><a href="#TOC"><span class="header-section-number">5.4</span> Trie</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Trie {
  <span class="dt">int</span> cnt, nrsons;
  Trie *son[<span class="dv">26</span>];

  Trie() {
    cnt = nrsons = <span class="dv">0</span>;
    memset(son, <span class="dv">0</span>, <span class="kw">sizeof</span>(son));
  }
};

Trie *T = <span class="kw">new</span> Trie;
<span class="dt">void</span> ins(Trie *node, <span class="dt">char</span> *s) {
  <span class="kw">if</span> (*s == &#39;\<span class="dv">0</span>&#39;) {
    node-&gt;cnt++;
    <span class="kw">return</span>;
  }
  <span class="kw">if</span> (node-&gt;son[ch] == <span class="dv">0</span>) {
    node-&gt;son[ch] = <span class="kw">new</span> Trie;
    node-&gt;nrsons++;
  }
  ins(node-&gt;son[ch], s + <span class="dv">1</span>);
}

<span class="dt">int</span> del(Trie *node, <span class="dt">char</span> *s) {
  <span class="kw">if</span> (*s == &#39;\<span class="dv">0</span>&#39;)
    node-&gt;cnt--;
  <span class="kw">else</span> <span class="kw">if</span> (del(node-&gt;son[ch], s + <span class="dv">1</span>)) {
    node-&gt;son[ch] = <span class="dv">0</span>;
    node-&gt;nrsons--;
  }
  <span class="kw">if</span> (node-&gt;cnt == <span class="dv">0</span> &amp;&amp; node-&gt;nrsons == <span class="dv">0</span> &amp;&amp; node != T) {
    <span class="kw">delete</span> node;
    <span class="kw">return</span> <span class="dv">1</span>;
  }
}
<span class="dt">int</span> freq(Trie *node, <span class="dt">char</span> *s) {
  <span class="kw">if</span> (*s == &#39;\<span class="dv">0</span>&#39;)
    <span class="kw">return</span> node-&gt;cnt;
  <span class="kw">if</span> (node-&gt;son[ch])
    <span class="kw">return</span> freq(node-&gt;son[ch], s + <span class="dv">1</span>);
  <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="dt">int</span> pref(Trie *node, <span class="dt">char</span> *s, <span class="dt">int</span> k) {
  <span class="kw">if</span> (*s == &#39;\<span class="dv">0</span>&#39; || node-&gt;son[ch] == <span class="dv">0</span>)
    <span class="kw">return</span> k;
  <span class="kw">return</span> pref(node-&gt;son[ch], s + <span class="dv">1</span>, k + <span class="dv">1</span>);
}</code></pre>
<h1 id="geometry"><a href="#TOC"><span class="header-section-number">6</span> Geometry</a></h1>
<h2 id="convex-hull"><a href="#TOC"><span class="header-section-number">6.1</span> Convex hull</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> pair&lt;<span class="dt">double</span>, <span class="dt">double</span>&gt; point;

<span class="dt">int</span> n;
point v[MAXN];
<span class="dt">int</span> head;
point stack[MAXN];

<span class="kw">inline</span> <span class="dt">double</span> cross_prod(<span class="dt">const</span> point&amp; A, <span class="dt">const</span> point&amp; B, <span class="dt">const</span> point&amp; C) {
  <span class="kw">return</span> (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
}
<span class="kw">inline</span> <span class="dt">bool</span> comp(<span class="dt">const</span> point&amp; A, <span class="dt">const</span> point&amp; B) {
  <span class="kw">return</span> cross_prod(v[<span class="dv">1</span>], A, B) &lt; <span class="dv">0</span>;
}
<span class="dt">void</span> sort_points() {
  <span class="dt">int</span> pos = <span class="dv">1</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; ++i)
    <span class="kw">if</span> (v[i] &lt; v[pos])
      pos = i;
  swap(v[<span class="dv">1</span>], v[pos]);
  sort(v + <span class="dv">2</span>, v + n + <span class="dv">1</span>, comp);
}
<span class="dt">void</span> convex_hull() {
  sort_points();

  stack[<span class="dv">1</span>] = v[<span class="dv">1</span>];
  stack[<span class="dv">2</span>] = v[<span class="dv">2</span>];
  head = <span class="dv">2</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">3</span>; i &lt;= n; ++i) {
    <span class="kw">while</span> (head &gt;= <span class="dv">2</span> &amp;&amp; cross_prod(stack[head - <span class="dv">1</span>], stack[head], v[i]) &gt; <span class="dv">0</span>)
      --head;
    stack[++head] = v[i];
  }
}</code></pre>
<h2 id="miscellaneous-geometry"><a href="#TOC"><span class="header-section-number">6.2</span> Miscellaneous geometry</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> point {
  <span class="dt">double</span> x, y;
  point() {}
  point(<span class="dt">double</span> x_, <span class="dt">double</span> y_): x(x_), y(y_) {}
  point(<span class="dt">const</span> point&amp; p): x(p.x), y(p.y) {}

  point <span class="kw">operator</span>+(<span class="dt">const</span> point&amp; p) <span class="dt">const</span> { <span class="kw">return</span> point(x + p.x, y + p.y); }
  point <span class="kw">operator</span>-(<span class="dt">const</span> point&amp; p) <span class="dt">const</span> { <span class="kw">return</span> point(x - p.x, y - p.y); }
  point <span class="kw">operator</span>*(<span class="dt">double</span> c) <span class="dt">const</span> { <span class="kw">return</span> point(x * c, y * c); }
  point <span class="kw">operator</span>/(<span class="dt">double</span> c) <span class="dt">const</span> { <span class="kw">return</span> point(x / c, y / c); }
};
ostream &amp;<span class="kw">operator</span>&lt;&lt;(ostream &amp;os, <span class="dt">const</span> point&amp; p) {
  os &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="st">&quot;)&quot;</span>;
}

<span class="dt">double</span> dot(point p, point q) { <span class="kw">return</span> p.x * q.x + p.y * q.y; }
<span class="dt">double</span> dist2(point p, point q) { <span class="kw">return</span> dot(p - q, p - q); }
<span class="dt">double</span> dist(point p, point q) { <span class="kw">return</span> sqrt(dist2(p, q)); }
<span class="dt">double</span> cross(point p, point q) { <span class="kw">return</span> p.x * q.y - p.y * q.x; }

<span class="dt">double</span> is_left(point a, point b, point c) {
  <span class="kw">return</span> cross(b - a, c - a);
}

point rotate_cw_90(point p) { <span class="kw">return</span> point(p.y, -p.x); }
point rotate_ccw_90(point p) { <span class="kw">return</span> point(-p.y, p.x); }
point rotate(point p, <span class="dt">double</span> a) {
  <span class="kw">return</span> point(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
}

point project_point_line(point a, point b, point c) {
  <span class="kw">return</span> a + (b - a) * dot(c - a, b - a) / dot(b - a, b - a);
}
point project_point_segment(point a, point b, point c) {
  <span class="dt">double</span> d = dot(b - a, b - a);
  <span class="kw">if</span> (abs(d) &lt; EPS) <span class="kw">return</span> a;
  d = dot(c - a, b - a) / d;
  <span class="kw">if</span> (d &lt; <span class="dv">0</span>) <span class="kw">return</span> a;
  <span class="kw">if</span> (d &gt; <span class="dv">1</span>) <span class="kw">return</span> b;
  <span class="kw">return</span> a + (b - a) * d;
}

<span class="dt">double</span> distance_point_segment(point a, point b, point c) {
  <span class="kw">return</span> sqrt(dist2(c, project_point_segment(a, b, c)));
}
<span class="dt">double</span> distance_point_plane(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> z,
    <span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> d) {
  <span class="kw">return</span> abs(a * x + b * y + c * z - d) / sqrt(a * a + b * b + c * c);
}

<span class="dt">bool</span> lines_parallel(point a, point b, point c, point d) {
  <span class="kw">return</span> abs(cross(b - a, c - d)) &lt; EPS;
}
<span class="dt">bool</span> lines_collinear(point a, point b, point c, point d) {
  <span class="kw">return</span> lines_parallel(a, b, c, d) &amp;&amp;
    abs(cross(a - b, a - c)) &lt; EPS &amp;&amp;
    abs(cross(c - d, c - a)) &lt; EPS;
}

<span class="dt">bool</span> segments_intersect(point a, point b, point c, point d) {
  <span class="kw">if</span> (lines_collinear(a, b, c, d)) {
    <span class="kw">if</span> (dist2(a, c) &lt; EPS || dist2(a, d) &lt; EPS ||
        dist2(b, c) &lt; EPS || dist2(b, d) &lt; EPS) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span> (dot(c - a, c - b) &gt; <span class="dv">0</span> &amp;&amp; dot(d - a, d - b) &gt; <span class="dv">0</span> &amp;&amp;
        dot(c - b, d - b) &gt; <span class="dv">0</span>) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
  }
  <span class="kw">if</span> (cross(d - a, b - a) * cross(c - a, b - a) &gt; <span class="dv">0</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (cross(a - c, d - c) * cross(b - c, d - c) &gt; <span class="dv">0</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">return</span> <span class="kw">true</span>;
}
point compute_line_intersection(point a, point b, point c, point d) {
  b = b - a; d = c - d; c = c - a;
  <span class="kw">return</span> a + b * cross(c, d) / cross(b, d);
}
point compute_circle_center(point a, point b, point c) {
  b = (a + b) / <span class="dv">2</span>;
  c = (a + c) / <span class="dv">2</span>;
  <span class="kw">return</span> compute_line_intersection(b, b + rotate_cw_90(a - b),
      c, c + rotate_cw_90(a - c));
}

<span class="dt">bool</span> point_in_poly(point p, <span class="dt">const</span> vector&lt;point&gt;&amp; v) {
  <span class="dt">int</span> wn = <span class="dv">0</span>;
  <span class="dt">int</span> n = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(v.size());
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="dt">int</span> j = (i + <span class="dv">1</span>) % n;
    <span class="kw">if</span> (v[i].y &lt;= p.y) {
      <span class="kw">if</span> (v[j].y &gt; p.y &amp;&amp; is_left(v[i], v[j], p) &gt; <span class="dv">0</span>)
        ++wn;
    } <span class="kw">else</span> {
      <span class="kw">if</span> (v[j].y &lt;= p.y &amp;&amp; is_left(v[i], v[j], p) &lt; <span class="dv">0</span>)
        --wn;
    }
  }
  <span class="kw">return</span> wn != <span class="dv">0</span>;
}
<span class="dt">bool</span> point_on_polygon(point p, <span class="dt">const</span> vector&lt;point&gt;&amp; v) {
  <span class="dt">int</span> n = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(v.size());
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="dt">int</span> j = (i + <span class="dv">1</span>) % n;
    <span class="kw">if</span> (dist2(project_point_segment(v[i], v[j], p), p) &lt; EPS)
      <span class="kw">return</span> <span class="kw">true</span>;
  }
  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">double</span> signed_area(<span class="dt">const</span> vector&lt;point&gt;&amp; v) {
  <span class="dt">int</span> n = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(v.size());
  <span class="dt">double</span> area = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="dt">int</span> j = (i + <span class="dv">1</span>) % n;
    area += v[i].x * v[j].y - v[j].x * v[i].y;
  }
  <span class="kw">return</span> area / <span class="fl">2.0</span>;
}
<span class="dt">double</span> area(<span class="dt">const</span> vector&lt;point&gt;&amp; v) {
  <span class="kw">return</span> abs(signed_area(v));
}
point centroid(<span class="dt">const</span> vector&lt;point&gt;&amp; v) {
  <span class="dt">int</span> n = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(v.size());
  point c(<span class="dv">0</span>, <span class="dv">0</span>);
  <span class="dt">double</span> scale = <span class="fl">6.0</span> * signed_area(v);
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="dt">int</span> j = (i + <span class="dv">1</span>) % n;
    c = c + (v[i] + v[j]) * (v[i].x * v[j].y - v[j].x * v[i].y);
  }
  <span class="kw">return</span> c / scale;
}
<span class="dt">bool</span> is_simple(<span class="dt">const</span> vector&lt;point&gt;&amp; v) {
  <span class="dt">int</span> n = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(v.size());
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="kw">for</span> (<span class="dt">int</span> k = i + <span class="dv">1</span>; k &lt; n; ++k) {
      <span class="dt">int</span> j = (i + <span class="dv">1</span>) % n;
      <span class="dt">int</span> l = (k + <span class="dv">1</span>) % n;
      <span class="kw">if</span> (i == l || j == k) <span class="kw">continue</span>;
      <span class="kw">if</span> (segments_intersect(v[i], v[j], v[k], v[l]))
        <span class="kw">return</span> <span class="kw">false</span>;
    }
  }
  <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
<h1 id="other"><a href="#TOC"><span class="header-section-number">7</span> Other</a></h1>
<h2 id="sat"><a href="#TOC"><span class="header-section-number">7.1</span> 2SAT</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; g[<span class="dv">202020</span>],gx[<span class="dv">202020</span>],last,stackx,viz,iss,low,aux,tare,gr_in;
vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; comp;
<span class="dt">int</span> N,index=<span class="dv">1</span>,k,Nn,M,x,y;
<span class="dt">int</span> rez[<span class="dv">201010</span>];
<span class="dt">int</span> notn(<span class="dt">int</span> x){
  <span class="kw">if</span>(x&lt;=N){
    <span class="kw">return</span> x + N;
  }
  <span class="kw">return</span> x-N;
}
<span class="dt">void</span> df(<span class="dt">int</span> x){
  viz[x] = index;
  low[x] = index;
  stackx[++k] = x;
  iss[x] = <span class="dv">1</span>;
  ++index;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;g[x].size();++i){
    <span class="kw">if</span>(viz[g[x][i]] == <span class="dv">0</span>){
      df(g[x][i]);
      low[x] = min(low[x],low[g[x][i]]);
    } <span class="kw">else</span>{
      <span class="kw">if</span>(iss[g[x][i]]){
        low[x] = min(low[x],low[g[x][i]]);
      }
    }
  }
  <span class="kw">if</span>(low[x] == viz[x]){
    aux.clear();
    <span class="kw">do</span>{
      aux.pb(stackx[k]);
      iss[stackx[k]] = <span class="dv">0</span>;
      --k;
    }<span class="kw">while</span>(stackx[k<span class="dv">+1</span>] != x);
    comp.pb(aux);
  }
}
<span class="dt">void</span> init(){
  index = <span class="dv">1</span>;
  stackx.resize(Nn<span class="dv">+10</span>);
  viz.resize(Nn<span class="dv">+10</span>);
  iss.resize(Nn<span class="dv">+10</span>);
  low.resize(Nn<span class="dv">+10</span>);
  tare.resize(Nn<span class="dv">+10</span>);
  last.resize(Nn<span class="dv">+10</span>);
  gr_in.resize(Nn<span class="dv">+10</span>);
}
<span class="dt">void</span> make_ctc(){
  Nn=<span class="dv">2</span>*N;
  init();
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=Nn;++i){
    <span class="kw">if</span>(viz[i]==<span class="dv">0</span>){
      df(i);
    }
  }
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;comp.size();++i){
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;comp[i].size();++j){
      tare[comp[i][j]] = i<span class="dv">+1</span>;
    }
  }
}
<span class="dt">void</span> solve(){
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=N;++i){
    <span class="kw">if</span>(tare[i] == tare[notn(i)]){
      printf(<span class="st">&quot;-1</span><span class="ch">\n</span><span class="st">&quot;</span>);
      <span class="kw">return</span>;
    }
  }
  <span class="dt">int</span> nod;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;comp.size();++i){
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;comp[i].size();++j){
      nod = comp[i][j];
      <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;g[nod].size();++k){
        <span class="dt">int</span> compv = tare[g[nod][k]];
        <span class="kw">if</span> ( last[compv] != i<span class="dv">+1</span> &amp;&amp; compv != i<span class="dv">+1</span> ){
          gx[i<span class="dv">+1</span>].pb(compv);
          ++gr_in[compv];
          last[compv]=i<span class="dv">+1</span>;
        }
      }
    }
  }
  queue&lt;<span class="dt">int</span>&gt; Q;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=comp.size();++i){
    <span class="kw">if</span>(gr_in[i]==<span class="dv">0</span>){
      Q.push(i);
    }
  }
  <span class="dt">int</span> nr = <span class="dv">0</span>;
  <span class="kw">while</span>(!Q.empty()){
    ++nr;
    nod = Q.front(); Q.pop();
    <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;gx[nod].size();++i){
      <span class="dt">int</span> nodv = gx[nod][i];
      --gr_in[nodv];
      <span class="kw">if</span> (gr_in[nodv]==<span class="dv">0</span>)
        Q.push(nodv);
    }
    <span class="kw">if</span> ( last[nod] == -<span class="dv">1</span> )  <span class="kw">continue</span> ;
    <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;comp[nod<span class="dv">-1</span>].size();++i){
      rez[comp[nod<span class="dv">-1</span>][i]] = <span class="dv">0</span>;
      rez[notn(comp[nod<span class="dv">-1</span>][i])] = <span class="dv">1</span>;
    }
    nod = tare[notn(comp[nod<span class="dv">-1</span>][<span class="dv">0</span>])];
    last[nod] = -<span class="dv">1</span>;
  }
}</code></pre>
<h2 id="kd-tree"><a href="#TOC"><span class="header-section-number">7.2</span> KD-tree</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> ntype sentry = numeric_limits&lt;ntype&gt;::max();
<span class="kw">struct</span> point {
  ntype x, y;
  point(ntype xx = <span class="dv">0</span>, ntype yy = <span class="dv">0</span>) : x(xx), y(yy) {}
};
<span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> point &amp;a, <span class="dt">const</span> point &amp;b) {
  <span class="kw">return</span> a.x == b.x &amp;&amp; a.y == b.y;
}
<span class="dt">bool</span> on_x(<span class="dt">const</span> point &amp;a, <span class="dt">const</span> point &amp;b) {
  <span class="kw">return</span> a.x &lt; b.x;
}
<span class="dt">bool</span> on_y(<span class="dt">const</span> point &amp;a, <span class="dt">const</span> point &amp;b) {
  <span class="kw">return</span> a.y &lt; b.y;
}
ntype pdist2(<span class="dt">const</span> point &amp;a, <span class="dt">const</span> point &amp;b) {
  ntype dx = a.x-b.x, dy = a.y-b.y;
  <span class="kw">return</span> dx*dx + dy*dy;
}
<span class="kw">struct</span> bbox {
  ntype x0, x1, y0, y1;
  bbox() : x0(sentry), x1(-sentry), y0(sentry), y1(-sentry) {}
  <span class="dt">void</span> compute(<span class="dt">const</span> vector&lt;point&gt; &amp;v) {
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; v.size(); ++i) {
      x0 = min(x0, v[i].x);   x1 = max(x1, v[i].x);
      y0 = min(y0, v[i].y);   y1 = max(y1, v[i].y);
    }
  }
  ntype distance(<span class="dt">const</span> point &amp;p) {
    <span class="kw">if</span> (p.x &lt; x0) {
      <span class="kw">if</span> (p.y &lt; y0)       <span class="kw">return</span> pdist2(point(x0, y0), p);
      <span class="kw">else</span> <span class="kw">if</span> (p.y &gt; y1)  <span class="kw">return</span> pdist2(point(x0, y1), p);
      <span class="kw">else</span>                <span class="kw">return</span> pdist2(point(x0, p.y), p);
    } <span class="kw">else</span> <span class="kw">if</span> (p.x &gt; x1) {
      <span class="kw">if</span> (p.y &lt; y0)       <span class="kw">return</span> pdist2(point(x1, y0), p);
      <span class="kw">else</span> <span class="kw">if</span> (p.y &gt; y1)  <span class="kw">return</span> pdist2(point(x1, y1), p);
      <span class="kw">else</span>                <span class="kw">return</span> pdist2(point(x1, p.y), p);
    } <span class="kw">else</span> {
      <span class="kw">if</span> (p.y &lt; y0)       <span class="kw">return</span> pdist2(point(p.x, y0), p);
      <span class="kw">else</span> <span class="kw">if</span> (p.y &gt; y1)  <span class="kw">return</span> pdist2(point(p.x, y1), p);
      <span class="kw">else</span>                <span class="kw">return</span> <span class="dv">0</span>;
    }
  }
};
<span class="kw">struct</span> kdnode {
  <span class="dt">bool</span> leaf;      <span class="co">// true if this is a leaf node (has one point)</span>
  point pt;       <span class="co">// the single point of this is a leaf</span>
  bbox bound;     <span class="co">// bounding box for set of points in children</span>

  kdnode *first, *second; <span class="co">// two children of this kd-node</span>

  kdnode() : leaf(<span class="kw">false</span>), first(<span class="dv">0</span>), second(<span class="dv">0</span>) {}
  ~kdnode() { <span class="kw">if</span> (first) <span class="kw">delete</span> first; <span class="kw">if</span> (second) <span class="kw">delete</span> second; }

  ntype intersect(<span class="dt">const</span> point &amp;p) {
    <span class="kw">return</span> bound.distance(p);
  }
  <span class="dt">void</span> construct(vector&lt;point&gt; &amp;vp) {
    bound.compute(vp);
    <span class="kw">if</span> (vp.size() == <span class="dv">1</span>) {
      leaf = <span class="kw">true</span>;
      pt = vp[<span class="dv">0</span>];
    } <span class="kw">else</span> {
      <span class="kw">if</span> (bound.x1-bound.x0 &gt;= bound.y1-bound.y0)
        sort(vp.begin(), vp.end(), on_x);
      <span class="kw">else</span>
        sort(vp.begin(), vp.end(), on_y);

      <span class="dt">int</span> half = vp.size()/<span class="dv">2</span>;
      vector&lt;point&gt; vl(vp.begin(), vp.begin()+half);
      vector&lt;point&gt; vr(vp.begin()+half, vp.end());
      first = <span class="kw">new</span> kdnode();   first-&gt;construct(vl);
      second = <span class="kw">new</span> kdnode();  second-&gt;construct(vr);
    }
  }
};

<span class="kw">struct</span> kdtree {
  kdnode *root;
  kdtree(<span class="dt">const</span> vector&lt;point&gt; &amp;vp) {
    vector&lt;point&gt; v(vp.begin(), vp.end());
    root = <span class="kw">new</span> kdnode();
    root-&gt;construct(v);
  }
  ~kdtree() { <span class="kw">delete</span> root; }
  ntype search(kdnode *node, <span class="dt">const</span> point &amp;p) {
    <span class="kw">if</span> (node-&gt;leaf) {
      <span class="kw">return</span> pdist2(p, node-&gt;pt);
    }
    ntype bfirst = node-&gt;first-&gt;intersect(p);
    ntype bsecond = node-&gt;second-&gt;intersect(p);

    <span class="kw">if</span> (bfirst &lt; bsecond) {
      ntype best = search(node-&gt;first, p);
      <span class="kw">if</span> (bsecond &lt; best)
        best = min(best, search(node-&gt;second, p));
      <span class="kw">return</span> best;
    } <span class="kw">else</span> {
      ntype best = search(node-&gt;second, p);
      <span class="kw">if</span> (bfirst &lt; best)
        best = min(best, search(node-&gt;first, p));
      <span class="kw">return</span> best;
    }
  }
  ntype nearest(<span class="dt">const</span> point &amp;p) {
    <span class="kw">return</span> search(root, p);
  }
};</code></pre>
</body>
</html>
